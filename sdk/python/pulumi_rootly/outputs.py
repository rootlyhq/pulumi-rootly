# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DashboardPanelParams',
    'DashboardPanelParamsDataset',
    'DashboardPanelParamsDatasetAggregate',
    'DashboardPanelParamsDatasetFilter',
    'DashboardPanelParamsDatasetFilterRule',
    'DashboardPanelParamsLegend',
    'DashboardPanelPosition',
    'EnvironmentSlackAlias',
    'EnvironmentSlackChannel',
    'EscalationLevelNotificationTargetParam',
    'FunctionalitySlackAlias',
    'FunctionalitySlackChannel',
    'IncidentTypeSlackAlias',
    'IncidentTypeSlackChannel',
    'RetrospectiveProcessRetrospectiveProcessMatchingCriteria',
    'ScheduleRotationActiveDayActiveTimeAttribute',
    'ScheduleRotationActiveTimeAttribute',
    'ServiceSlackAlias',
    'ServiceSlackChannel',
    'SeveritySlackAlias',
    'SeveritySlackChannel',
    'TeamSlackAlias',
    'TeamSlackChannel',
    'WorkflowActionItemTriggerParams',
    'WorkflowAlertTriggerParams',
    'WorkflowIncidentTriggerParams',
    'WorkflowPostMortemTriggerParams',
    'WorkflowPulseTriggerParams',
    'WorkflowSimpleTriggerParams',
    'WorkflowTaskAddActionItemTaskParams',
    'WorkflowTaskAddActionItemTaskParamsPostToSlackChannel',
    'WorkflowTaskAddRoleTaskParams',
    'WorkflowTaskAddSlackBookmarkTaskParams',
    'WorkflowTaskAddTeamTaskParams',
    'WorkflowTaskAddToTimelineTaskParams',
    'WorkflowTaskAddToTimelineTaskParamsPostToSlackChannel',
    'WorkflowTaskArchiveSlackChannelsTaskParams',
    'WorkflowTaskArchiveSlackChannelsTaskParamsChannel',
    'WorkflowTaskAttachDatadogDashboardsTaskParams',
    'WorkflowTaskAttachDatadogDashboardsTaskParamsDashboard',
    'WorkflowTaskAttachDatadogDashboardsTaskParamsPostToSlackChannel',
    'WorkflowTaskAutoAssignRoleOpsgenieTaskParams',
    'WorkflowTaskAutoAssignRolePagerdutyTaskParams',
    'WorkflowTaskAutoAssignRoleRootlyTaskParams',
    'WorkflowTaskAutoAssignRoleVictorOpsTaskParams',
    'WorkflowTaskCallPeopleTaskParams',
    'WorkflowTaskChangeSlackChannelPrivacyTaskParams',
    'WorkflowTaskCreateAirtableTableRecordTaskParams',
    'WorkflowTaskCreateAsanaSubtaskTaskParams',
    'WorkflowTaskCreateAsanaTaskTaskParams',
    'WorkflowTaskCreateAsanaTaskTaskParamsProject',
    'WorkflowTaskCreateClickupTaskTaskParams',
    'WorkflowTaskCreateConfluencePageTaskParams',
    'WorkflowTaskCreateDatadogNotebookTaskParams',
    'WorkflowTaskCreateDropboxPaperPageTaskParams',
    'WorkflowTaskCreateGithubIssueTaskParams',
    'WorkflowTaskCreateGitlabIssueTaskParams',
    'WorkflowTaskCreateGoToMeetingTaskParams',
    'WorkflowTaskCreateGoToMeetingTaskParamsPostToSlackChannel',
    'WorkflowTaskCreateGoogleCalendarEventTaskParams',
    'WorkflowTaskCreateGoogleCalendarEventTaskParamsPostToSlackChannel',
    'WorkflowTaskCreateGoogleDocsPageTaskParams',
    'WorkflowTaskCreateGoogleDocsPermissionsTaskParams',
    'WorkflowTaskCreateGoogleMeetingTaskParams',
    'WorkflowTaskCreateGoogleMeetingTaskParamsPostToSlackChannel',
    'WorkflowTaskCreateIncidentPostmortemTaskParams',
    'WorkflowTaskCreateIncidentTaskParams',
    'WorkflowTaskCreateJiraIssueTaskParams',
    'WorkflowTaskCreateJiraSubtaskTaskParams',
    'WorkflowTaskCreateLinearIssueCommentTaskParams',
    'WorkflowTaskCreateLinearIssueTaskParams',
    'WorkflowTaskCreateLinearIssueTaskParamsLabel',
    'WorkflowTaskCreateLinearSubtaskIssueTaskParams',
    'WorkflowTaskCreateMicrosoftTeamsMeetingTaskParams',
    'WorkflowTaskCreateMicrosoftTeamsMeetingTaskParamsPostToSlackChannel',
    'WorkflowTaskCreateNotionPageTaskParams',
    'WorkflowTaskCreateOpsgenieAlertTaskParams',
    'WorkflowTaskCreateOpsgenieAlertTaskParamsEscalation',
    'WorkflowTaskCreateOpsgenieAlertTaskParamsSchedule',
    'WorkflowTaskCreateOpsgenieAlertTaskParamsTeam',
    'WorkflowTaskCreateOpsgenieAlertTaskParamsUser',
    'WorkflowTaskCreateOutlookEventTaskParams',
    'WorkflowTaskCreateOutlookEventTaskParamsPostToSlackChannel',
    'WorkflowTaskCreatePagerdutyStatusUpdateTaskParams',
    'WorkflowTaskCreatePagertreeAlertTaskParams',
    'WorkflowTaskCreatePagertreeAlertTaskParamsTeam',
    'WorkflowTaskCreatePagertreeAlertTaskParamsUser',
    'WorkflowTaskCreateQuipPageTaskParams',
    'WorkflowTaskCreateServiceNowIncidentTaskParams',
    'WorkflowTaskCreateSharepointPageTaskParams',
    'WorkflowTaskCreateShortcutStoryTaskParams',
    'WorkflowTaskCreateShortcutTaskTaskParams',
    'WorkflowTaskCreateSlackChannelTaskParams',
    'WorkflowTaskCreateTrelloCardTaskParams',
    'WorkflowTaskCreateTrelloCardTaskParamsLabel',
    'WorkflowTaskCreateWebexMeetingTaskParams',
    'WorkflowTaskCreateWebexMeetingTaskParamsPostToSlackChannel',
    'WorkflowTaskCreateZendeskJiraLinkTaskParams',
    'WorkflowTaskCreateZendeskTicketTaskParams',
    'WorkflowTaskCreateZoomMeetingTaskParams',
    'WorkflowTaskCreateZoomMeetingTaskParamsPostToSlackChannel',
    'WorkflowTaskGetAlertsTaskParams',
    'WorkflowTaskGetAlertsTaskParamsPostToSlackChannel',
    'WorkflowTaskGetGithubCommitsTaskParams',
    'WorkflowTaskGetGithubCommitsTaskParamsPostToSlackChannel',
    'WorkflowTaskGetGitlabCommitsTaskParams',
    'WorkflowTaskGetGitlabCommitsTaskParamsPostToSlackChannel',
    'WorkflowTaskGetPulsesTaskParams',
    'WorkflowTaskGetPulsesTaskParamsPostToSlackChannel',
    'WorkflowTaskHttpClientTaskParams',
    'WorkflowTaskHttpClientTaskParamsPostToSlackChannel',
    'WorkflowTaskInviteToSlackChannelOpsgenieTaskParams',
    'WorkflowTaskInviteToSlackChannelOpsgenieTaskParamsChannel',
    'WorkflowTaskInviteToSlackChannelPagerdutyTaskParams',
    'WorkflowTaskInviteToSlackChannelPagerdutyTaskParamsChannel',
    'WorkflowTaskInviteToSlackChannelRootlyTaskParams',
    'WorkflowTaskInviteToSlackChannelRootlyTaskParamsChannel',
    'WorkflowTaskInviteToSlackChannelTaskParams',
    'WorkflowTaskInviteToSlackChannelTaskParamsSlackUser',
    'WorkflowTaskInviteToSlackChannelTaskParamsSlackUserGroup',
    'WorkflowTaskInviteToSlackChannelVictorOpsTaskParams',
    'WorkflowTaskInviteToSlackChannelVictorOpsTaskParamsChannel',
    'WorkflowTaskPageOpsgenieOnCallRespondersTaskParams',
    'WorkflowTaskPageOpsgenieOnCallRespondersTaskParamsTeam',
    'WorkflowTaskPageOpsgenieOnCallRespondersTaskParamsUser',
    'WorkflowTaskPagePagerdutyOnCallRespondersTaskParams',
    'WorkflowTaskPagePagerdutyOnCallRespondersTaskParamsEscalationPolicy',
    'WorkflowTaskPagePagerdutyOnCallRespondersTaskParamsUser',
    'WorkflowTaskPageRootlyOnCallRespondersTaskParams',
    'WorkflowTaskPageVictorOpsOnCallRespondersTaskParams',
    'WorkflowTaskPageVictorOpsOnCallRespondersTaskParamsEscalationPolicy',
    'WorkflowTaskPageVictorOpsOnCallRespondersTaskParamsUser',
    'WorkflowTaskPrintTaskParams',
    'WorkflowTaskPublishIncidentTaskParams',
    'WorkflowTaskRedisClientTaskParams',
    'WorkflowTaskRedisClientTaskParamsPostToSlackChannel',
    'WorkflowTaskRemoveGoogleDocsPermissionsTaskParams',
    'WorkflowTaskRenameSlackChannelTaskParams',
    'WorkflowTaskRunCommandHerokuTaskParams',
    'WorkflowTaskRunCommandHerokuTaskParamsPostToSlackChannel',
    'WorkflowTaskSendDashboardReportTaskParams',
    'WorkflowTaskSendEmailTaskParams',
    'WorkflowTaskSendSlackBlocksTaskParams',
    'WorkflowTaskSendSlackBlocksTaskParamsChannel',
    'WorkflowTaskSendSlackBlocksTaskParamsSlackUser',
    'WorkflowTaskSendSlackBlocksTaskParamsSlackUserGroup',
    'WorkflowTaskSendSlackMessageTaskParams',
    'WorkflowTaskSendSlackMessageTaskParamsChannel',
    'WorkflowTaskSendSlackMessageTaskParamsSlackUser',
    'WorkflowTaskSendSlackMessageTaskParamsSlackUserGroup',
    'WorkflowTaskSendSmsTaskParams',
    'WorkflowTaskSendWhatsappMessageTaskParams',
    'WorkflowTaskSnapshotDatadogGraphTaskParams',
    'WorkflowTaskSnapshotDatadogGraphTaskParamsDashboard',
    'WorkflowTaskSnapshotDatadogGraphTaskParamsPostToSlackChannel',
    'WorkflowTaskSnapshotGrafanaDashboardTaskParams',
    'WorkflowTaskSnapshotGrafanaDashboardTaskParamsDashboard',
    'WorkflowTaskSnapshotGrafanaDashboardTaskParamsPostToSlackChannel',
    'WorkflowTaskSnapshotLookerLookTaskParams',
    'WorkflowTaskSnapshotLookerLookTaskParamsDashboard',
    'WorkflowTaskSnapshotLookerLookTaskParamsPostToSlackChannel',
    'WorkflowTaskSnapshotNewRelicGraphTaskParams',
    'WorkflowTaskSnapshotNewRelicGraphTaskParamsPostToSlackChannel',
    'WorkflowTaskTriggerWorkflowTaskParams',
    'WorkflowTaskTweetTwitterMessageTaskParams',
    'WorkflowTaskUpdateActionItemTaskParams',
    'WorkflowTaskUpdateAirtableTableRecordTaskParams',
    'WorkflowTaskUpdateAsanaTaskTaskParams',
    'WorkflowTaskUpdateAttachedAlertsTaskParams',
    'WorkflowTaskUpdateClickupTaskTaskParams',
    'WorkflowTaskUpdateGithubIssueTaskParams',
    'WorkflowTaskUpdateGitlabIssueTaskParams',
    'WorkflowTaskUpdateGoogleCalendarEventTaskParams',
    'WorkflowTaskUpdateGoogleCalendarEventTaskParamsPostToSlackChannel',
    'WorkflowTaskUpdateGoogleDocsPageTaskParams',
    'WorkflowTaskUpdateIncidentPostmortemTaskParams',
    'WorkflowTaskUpdateIncidentTaskParams',
    'WorkflowTaskUpdateJiraIssueTaskParams',
    'WorkflowTaskUpdateLinearIssueTaskParams',
    'WorkflowTaskUpdateLinearIssueTaskParamsLabel',
    'WorkflowTaskUpdateNotionPageTaskParams',
    'WorkflowTaskUpdateOpsgenieAlertTaskParams',
    'WorkflowTaskUpdateOpsgenieIncidentTaskParams',
    'WorkflowTaskUpdatePagerdutyIncidentTaskParams',
    'WorkflowTaskUpdatePagertreeAlertTaskParams',
    'WorkflowTaskUpdatePagertreeAlertTaskParamsTeam',
    'WorkflowTaskUpdatePagertreeAlertTaskParamsUser',
    'WorkflowTaskUpdateServiceNowIncidentTaskParams',
    'WorkflowTaskUpdateShortcutStoryTaskParams',
    'WorkflowTaskUpdateShortcutTaskTaskParams',
    'WorkflowTaskUpdateSlackChannelTopicTaskParams',
    'WorkflowTaskUpdateStatusTaskParams',
    'WorkflowTaskUpdateTrelloCardTaskParams',
    'WorkflowTaskUpdateTrelloCardTaskParamsLabel',
    'WorkflowTaskUpdateVictorOpsIncidentTaskParams',
    'WorkflowTaskUpdateZendeskTicketTaskParams',
    'GetCausesCauseResult',
    'GetCustomFieldOptionsCustomFieldOptionResult',
    'GetCustomFieldsCustomFieldResult',
    'GetEnvironmentsEnvironmentResult',
    'GetFunctionalitiesFunctionalityResult',
    'GetIncidentRolesIncidentRoleResult',
    'GetIncidentTypesIncidentTypeResult',
    'GetServicesServiceResult',
    'GetSeveritiesSeverityResult',
    'GetTeamsTeamResult',
]

@pulumi.output_type
class DashboardPanelParams(dict):
    def __init__(__self__, *,
                 display: str,
                 datasets: Optional[Sequence['outputs.DashboardPanelParamsDataset']] = None,
                 legend: Optional['outputs.DashboardPanelParamsLegend'] = None):
        pulumi.set(__self__, "display", display)
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if legend is not None:
            pulumi.set(__self__, "legend", legend)

    @property
    @pulumi.getter
    def display(self) -> str:
        return pulumi.get(self, "display")

    @property
    @pulumi.getter
    def datasets(self) -> Optional[Sequence['outputs.DashboardPanelParamsDataset']]:
        return pulumi.get(self, "datasets")

    @property
    @pulumi.getter
    def legend(self) -> Optional['outputs.DashboardPanelParamsLegend']:
        return pulumi.get(self, "legend")


@pulumi.output_type
class DashboardPanelParamsDataset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelParamsDataset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelParamsDataset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelParamsDataset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection: str,
                 aggregate: Optional['outputs.DashboardPanelParamsDatasetAggregate'] = None,
                 filters: Optional[Sequence['outputs.DashboardPanelParamsDatasetFilter']] = None,
                 group_by: Optional[str] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "collection", collection)
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def collection(self) -> str:
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter
    def aggregate(self) -> Optional['outputs.DashboardPanelParamsDatasetAggregate']:
        return pulumi.get(self, "aggregate")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.DashboardPanelParamsDatasetFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[str]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class DashboardPanelParamsDatasetAggregate(dict):
    def __init__(__self__, *,
                 cumulative: bool,
                 key: str,
                 operation: str):
        pulumi.set(__self__, "cumulative", cumulative)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operation", operation)

    @property
    @pulumi.getter
    def cumulative(self) -> bool:
        return pulumi.get(self, "cumulative")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")


@pulumi.output_type
class DashboardPanelParamsDatasetFilter(dict):
    def __init__(__self__, *,
                 operation: str,
                 rules: Optional[Sequence['outputs.DashboardPanelParamsDatasetFilterRule']] = None):
        pulumi.set(__self__, "operation", operation)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.DashboardPanelParamsDatasetFilterRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class DashboardPanelParamsDatasetFilterRule(dict):
    def __init__(__self__, *,
                 condition: str,
                 key: str,
                 operation: str,
                 value: str):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def condition(self) -> str:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operation(self) -> str:
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardPanelParamsLegend(dict):
    def __init__(__self__, *,
                 groups: str):
        pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def groups(self) -> str:
        return pulumi.get(self, "groups")


@pulumi.output_type
class DashboardPanelPosition(dict):
    def __init__(__self__, *,
                 h: int,
                 w: int,
                 x: int,
                 y: int):
        pulumi.set(__self__, "h", h)
        pulumi.set(__self__, "w", w)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def h(self) -> int:
        return pulumi.get(self, "h")

    @property
    @pulumi.getter
    def w(self) -> int:
        return pulumi.get(self, "w")

    @property
    @pulumi.getter
    def x(self) -> int:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        return pulumi.get(self, "y")


@pulumi.output_type
class EnvironmentSlackAlias(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class EnvironmentSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class EscalationLevelNotificationTargetParam(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class FunctionalitySlackAlias(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class FunctionalitySlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class IncidentTypeSlackAlias(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class IncidentTypeSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RetrospectiveProcessRetrospectiveProcessMatchingCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "incidentTypeIds":
            suggest = "incident_type_ids"
        elif key == "severityIds":
            suggest = "severity_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetrospectiveProcessRetrospectiveProcessMatchingCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetrospectiveProcessRetrospectiveProcessMatchingCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetrospectiveProcessRetrospectiveProcessMatchingCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Optional[Sequence[str]] = None,
                 incident_type_ids: Optional[Sequence[str]] = None,
                 severity_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] group_ids: Teams for process matching criteria.
        :param Sequence[str] incident_type_ids: Incident types for process matching criteria.
        :param Sequence[str] severity_ids: Severities for process matching criteria.
        """
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if incident_type_ids is not None:
            pulumi.set(__self__, "incident_type_ids", incident_type_ids)
        if severity_ids is not None:
            pulumi.set(__self__, "severity_ids", severity_ids)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[str]]:
        """
        Teams for process matching criteria.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="incidentTypeIds")
    def incident_type_ids(self) -> Optional[Sequence[str]]:
        """
        Incident types for process matching criteria.
        """
        return pulumi.get(self, "incident_type_ids")

    @property
    @pulumi.getter(name="severityIds")
    def severity_ids(self) -> Optional[Sequence[str]]:
        """
        Severities for process matching criteria.
        """
        return pulumi.get(self, "severity_ids")


@pulumi.output_type
class ScheduleRotationActiveDayActiveTimeAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleRotationActiveDayActiveTimeAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleRotationActiveDayActiveTimeAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleRotationActiveDayActiveTimeAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ScheduleRotationActiveTimeAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleRotationActiveTimeAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleRotationActiveTimeAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleRotationActiveTimeAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ServiceSlackAlias(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class ServiceSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class SeveritySlackAlias(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class SeveritySlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class TeamSlackAlias(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class TeamSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowActionItemTriggerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentActionItemCondition":
            suggest = "incident_action_item_condition"
        elif key == "incidentActionItemConditionGroup":
            suggest = "incident_action_item_condition_group"
        elif key == "incidentActionItemConditionKind":
            suggest = "incident_action_item_condition_kind"
        elif key == "incidentActionItemConditionPriority":
            suggest = "incident_action_item_condition_priority"
        elif key == "incidentActionItemConditionStatus":
            suggest = "incident_action_item_condition_status"
        elif key == "incidentActionItemGroupIds":
            suggest = "incident_action_item_group_ids"
        elif key == "incidentActionItemKinds":
            suggest = "incident_action_item_kinds"
        elif key == "incidentActionItemPriorities":
            suggest = "incident_action_item_priorities"
        elif key == "incidentActionItemStatuses":
            suggest = "incident_action_item_statuses"
        elif key == "incidentCondition":
            suggest = "incident_condition"
        elif key == "incidentConditionAcknowledgedAt":
            suggest = "incident_condition_acknowledged_at"
        elif key == "incidentConditionDetectedAt":
            suggest = "incident_condition_detected_at"
        elif key == "incidentConditionEnvironment":
            suggest = "incident_condition_environment"
        elif key == "incidentConditionFunctionality":
            suggest = "incident_condition_functionality"
        elif key == "incidentConditionGroup":
            suggest = "incident_condition_group"
        elif key == "incidentConditionIncidentRoles":
            suggest = "incident_condition_incident_roles"
        elif key == "incidentConditionIncidentType":
            suggest = "incident_condition_incident_type"
        elif key == "incidentConditionKind":
            suggest = "incident_condition_kind"
        elif key == "incidentConditionMitigatedAt":
            suggest = "incident_condition_mitigated_at"
        elif key == "incidentConditionResolvedAt":
            suggest = "incident_condition_resolved_at"
        elif key == "incidentConditionService":
            suggest = "incident_condition_service"
        elif key == "incidentConditionSeverity":
            suggest = "incident_condition_severity"
        elif key == "incidentConditionStartedAt":
            suggest = "incident_condition_started_at"
        elif key == "incidentConditionStatus":
            suggest = "incident_condition_status"
        elif key == "incidentConditionSummary":
            suggest = "incident_condition_summary"
        elif key == "incidentConditionVisibility":
            suggest = "incident_condition_visibility"
        elif key == "incidentConditionalInactivity":
            suggest = "incident_conditional_inactivity"
        elif key == "incidentInactivityDuration":
            suggest = "incident_inactivity_duration"
        elif key == "incidentKinds":
            suggest = "incident_kinds"
        elif key == "incidentStatuses":
            suggest = "incident_statuses"
        elif key == "incidentVisibilities":
            suggest = "incident_visibilities"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowActionItemTriggerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowActionItemTriggerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowActionItemTriggerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_action_item_condition: Optional[str] = None,
                 incident_action_item_condition_group: Optional[str] = None,
                 incident_action_item_condition_kind: Optional[str] = None,
                 incident_action_item_condition_priority: Optional[str] = None,
                 incident_action_item_condition_status: Optional[str] = None,
                 incident_action_item_group_ids: Optional[Sequence[str]] = None,
                 incident_action_item_kinds: Optional[Sequence[str]] = None,
                 incident_action_item_priorities: Optional[Sequence[str]] = None,
                 incident_action_item_statuses: Optional[Sequence[str]] = None,
                 incident_condition: Optional[str] = None,
                 incident_condition_acknowledged_at: Optional[str] = None,
                 incident_condition_detected_at: Optional[str] = None,
                 incident_condition_environment: Optional[str] = None,
                 incident_condition_functionality: Optional[str] = None,
                 incident_condition_group: Optional[str] = None,
                 incident_condition_incident_roles: Optional[str] = None,
                 incident_condition_incident_type: Optional[str] = None,
                 incident_condition_kind: Optional[str] = None,
                 incident_condition_mitigated_at: Optional[str] = None,
                 incident_condition_resolved_at: Optional[str] = None,
                 incident_condition_service: Optional[str] = None,
                 incident_condition_severity: Optional[str] = None,
                 incident_condition_started_at: Optional[str] = None,
                 incident_condition_status: Optional[str] = None,
                 incident_condition_summary: Optional[str] = None,
                 incident_condition_visibility: Optional[str] = None,
                 incident_conditional_inactivity: Optional[str] = None,
                 incident_inactivity_duration: Optional[str] = None,
                 incident_kinds: Optional[Sequence[str]] = None,
                 incident_statuses: Optional[Sequence[str]] = None,
                 incident_visibilities: Optional[Sequence[str]] = None,
                 trigger_type: Optional[str] = None,
                 triggers: Optional[Sequence[str]] = None):
        """
        :param str incident_action_item_condition: Value must be one off `ALL`, `ANY`, `NONE`.
        :param str incident_action_item_condition_group: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_action_item_condition_kind: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_action_item_condition_priority: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_action_item_condition_status: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param Sequence[str] incident_action_item_kinds: Value must be one of `task`, `follow_up`.
        :param Sequence[str] incident_action_item_priorities: Value must be one of `high`, `medium`, `low`.
        :param Sequence[str] incident_action_item_statuses: Value must be one of `open`, `in_progress`, `cancelled`, `done`.
        :param str incident_condition: Value must be one off `ALL`, `ANY`, `NONE`.
        :param str incident_condition_environment: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_functionality: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_group: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_incident_roles: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_incident_type: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_kind: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_service: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_severity: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_status: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_visibility: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_inactivity_duration: ex. 10 min, 1h, 3 days, 2 weeks
        :param Sequence[str] incident_kinds: Value must be one of `test`, `test_sub`, `example`, `example_sub`, `normal`, `normal_sub`, `backfilled`, `scheduled`.
        :param Sequence[str] incident_statuses: Value must be one of `in_triage`, `started`, `detected`, `acknowledged`, `mitigated`, `resolved`, `cancelled`, `scheduled`, `in_progress`, `completed`.
        :param str trigger_type: Value must be one off `action_item`.
        :param Sequence[str] triggers: Actions that trigger the workflow. One of custom*fields.\\n\\n.updated, incident*updated, action*item*created, action*item*updated, assigned*user*updated, summary*updated, description*updated, status*updated, priority*updated, due*date*updated, teams*updated, slack*command
        """
        if incident_action_item_condition is not None:
            pulumi.set(__self__, "incident_action_item_condition", incident_action_item_condition)
        if incident_action_item_condition_group is not None:
            pulumi.set(__self__, "incident_action_item_condition_group", incident_action_item_condition_group)
        if incident_action_item_condition_kind is not None:
            pulumi.set(__self__, "incident_action_item_condition_kind", incident_action_item_condition_kind)
        if incident_action_item_condition_priority is not None:
            pulumi.set(__self__, "incident_action_item_condition_priority", incident_action_item_condition_priority)
        if incident_action_item_condition_status is not None:
            pulumi.set(__self__, "incident_action_item_condition_status", incident_action_item_condition_status)
        if incident_action_item_group_ids is not None:
            pulumi.set(__self__, "incident_action_item_group_ids", incident_action_item_group_ids)
        if incident_action_item_kinds is not None:
            pulumi.set(__self__, "incident_action_item_kinds", incident_action_item_kinds)
        if incident_action_item_priorities is not None:
            pulumi.set(__self__, "incident_action_item_priorities", incident_action_item_priorities)
        if incident_action_item_statuses is not None:
            pulumi.set(__self__, "incident_action_item_statuses", incident_action_item_statuses)
        if incident_condition is not None:
            pulumi.set(__self__, "incident_condition", incident_condition)
        if incident_condition_acknowledged_at is not None:
            pulumi.set(__self__, "incident_condition_acknowledged_at", incident_condition_acknowledged_at)
        if incident_condition_detected_at is not None:
            pulumi.set(__self__, "incident_condition_detected_at", incident_condition_detected_at)
        if incident_condition_environment is not None:
            pulumi.set(__self__, "incident_condition_environment", incident_condition_environment)
        if incident_condition_functionality is not None:
            pulumi.set(__self__, "incident_condition_functionality", incident_condition_functionality)
        if incident_condition_group is not None:
            pulumi.set(__self__, "incident_condition_group", incident_condition_group)
        if incident_condition_incident_roles is not None:
            pulumi.set(__self__, "incident_condition_incident_roles", incident_condition_incident_roles)
        if incident_condition_incident_type is not None:
            pulumi.set(__self__, "incident_condition_incident_type", incident_condition_incident_type)
        if incident_condition_kind is not None:
            pulumi.set(__self__, "incident_condition_kind", incident_condition_kind)
        if incident_condition_mitigated_at is not None:
            pulumi.set(__self__, "incident_condition_mitigated_at", incident_condition_mitigated_at)
        if incident_condition_resolved_at is not None:
            pulumi.set(__self__, "incident_condition_resolved_at", incident_condition_resolved_at)
        if incident_condition_service is not None:
            pulumi.set(__self__, "incident_condition_service", incident_condition_service)
        if incident_condition_severity is not None:
            pulumi.set(__self__, "incident_condition_severity", incident_condition_severity)
        if incident_condition_started_at is not None:
            pulumi.set(__self__, "incident_condition_started_at", incident_condition_started_at)
        if incident_condition_status is not None:
            pulumi.set(__self__, "incident_condition_status", incident_condition_status)
        if incident_condition_summary is not None:
            pulumi.set(__self__, "incident_condition_summary", incident_condition_summary)
        if incident_condition_visibility is not None:
            pulumi.set(__self__, "incident_condition_visibility", incident_condition_visibility)
        if incident_conditional_inactivity is not None:
            pulumi.set(__self__, "incident_conditional_inactivity", incident_conditional_inactivity)
        if incident_inactivity_duration is not None:
            pulumi.set(__self__, "incident_inactivity_duration", incident_inactivity_duration)
        if incident_kinds is not None:
            pulumi.set(__self__, "incident_kinds", incident_kinds)
        if incident_statuses is not None:
            pulumi.set(__self__, "incident_statuses", incident_statuses)
        if incident_visibilities is not None:
            pulumi.set(__self__, "incident_visibilities", incident_visibilities)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="incidentActionItemCondition")
    def incident_action_item_condition(self) -> Optional[str]:
        """
        Value must be one off `ALL`, `ANY`, `NONE`.
        """
        return pulumi.get(self, "incident_action_item_condition")

    @property
    @pulumi.getter(name="incidentActionItemConditionGroup")
    def incident_action_item_condition_group(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_action_item_condition_group")

    @property
    @pulumi.getter(name="incidentActionItemConditionKind")
    def incident_action_item_condition_kind(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_action_item_condition_kind")

    @property
    @pulumi.getter(name="incidentActionItemConditionPriority")
    def incident_action_item_condition_priority(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_action_item_condition_priority")

    @property
    @pulumi.getter(name="incidentActionItemConditionStatus")
    def incident_action_item_condition_status(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_action_item_condition_status")

    @property
    @pulumi.getter(name="incidentActionItemGroupIds")
    def incident_action_item_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "incident_action_item_group_ids")

    @property
    @pulumi.getter(name="incidentActionItemKinds")
    def incident_action_item_kinds(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `task`, `follow_up`.
        """
        return pulumi.get(self, "incident_action_item_kinds")

    @property
    @pulumi.getter(name="incidentActionItemPriorities")
    def incident_action_item_priorities(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `high`, `medium`, `low`.
        """
        return pulumi.get(self, "incident_action_item_priorities")

    @property
    @pulumi.getter(name="incidentActionItemStatuses")
    def incident_action_item_statuses(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `open`, `in_progress`, `cancelled`, `done`.
        """
        return pulumi.get(self, "incident_action_item_statuses")

    @property
    @pulumi.getter(name="incidentCondition")
    def incident_condition(self) -> Optional[str]:
        """
        Value must be one off `ALL`, `ANY`, `NONE`.
        """
        return pulumi.get(self, "incident_condition")

    @property
    @pulumi.getter(name="incidentConditionAcknowledgedAt")
    def incident_condition_acknowledged_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_acknowledged_at")

    @property
    @pulumi.getter(name="incidentConditionDetectedAt")
    def incident_condition_detected_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_detected_at")

    @property
    @pulumi.getter(name="incidentConditionEnvironment")
    def incident_condition_environment(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_environment")

    @property
    @pulumi.getter(name="incidentConditionFunctionality")
    def incident_condition_functionality(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_functionality")

    @property
    @pulumi.getter(name="incidentConditionGroup")
    def incident_condition_group(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_group")

    @property
    @pulumi.getter(name="incidentConditionIncidentRoles")
    def incident_condition_incident_roles(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_incident_roles")

    @property
    @pulumi.getter(name="incidentConditionIncidentType")
    def incident_condition_incident_type(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_incident_type")

    @property
    @pulumi.getter(name="incidentConditionKind")
    def incident_condition_kind(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_kind")

    @property
    @pulumi.getter(name="incidentConditionMitigatedAt")
    def incident_condition_mitigated_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_mitigated_at")

    @property
    @pulumi.getter(name="incidentConditionResolvedAt")
    def incident_condition_resolved_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_resolved_at")

    @property
    @pulumi.getter(name="incidentConditionService")
    def incident_condition_service(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_service")

    @property
    @pulumi.getter(name="incidentConditionSeverity")
    def incident_condition_severity(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_severity")

    @property
    @pulumi.getter(name="incidentConditionStartedAt")
    def incident_condition_started_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_started_at")

    @property
    @pulumi.getter(name="incidentConditionStatus")
    def incident_condition_status(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_status")

    @property
    @pulumi.getter(name="incidentConditionSummary")
    def incident_condition_summary(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_summary")

    @property
    @pulumi.getter(name="incidentConditionVisibility")
    def incident_condition_visibility(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_visibility")

    @property
    @pulumi.getter(name="incidentConditionalInactivity")
    def incident_conditional_inactivity(self) -> Optional[str]:
        return pulumi.get(self, "incident_conditional_inactivity")

    @property
    @pulumi.getter(name="incidentInactivityDuration")
    def incident_inactivity_duration(self) -> Optional[str]:
        """
        ex. 10 min, 1h, 3 days, 2 weeks
        """
        return pulumi.get(self, "incident_inactivity_duration")

    @property
    @pulumi.getter(name="incidentKinds")
    def incident_kinds(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `test`, `test_sub`, `example`, `example_sub`, `normal`, `normal_sub`, `backfilled`, `scheduled`.
        """
        return pulumi.get(self, "incident_kinds")

    @property
    @pulumi.getter(name="incidentStatuses")
    def incident_statuses(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `in_triage`, `started`, `detected`, `acknowledged`, `mitigated`, `resolved`, `cancelled`, `scheduled`, `in_progress`, `completed`.
        """
        return pulumi.get(self, "incident_statuses")

    @property
    @pulumi.getter(name="incidentVisibilities")
    def incident_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "incident_visibilities")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[str]:
        """
        Value must be one off `action_item`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence[str]]:
        """
        Actions that trigger the workflow. One of custom*fields.\\n\\n.updated, incident*updated, action*item*created, action*item*updated, assigned*user*updated, summary*updated, description*updated, status*updated, priority*updated, due*date*updated, teams*updated, slack*command
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class WorkflowAlertTriggerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "alertConditionLabel":
            suggest = "alert_condition_label"
        elif key == "alertConditionLabelUseRegexp":
            suggest = "alert_condition_label_use_regexp"
        elif key == "alertConditionPayload":
            suggest = "alert_condition_payload"
        elif key == "alertConditionPayloadUseRegexp":
            suggest = "alert_condition_payload_use_regexp"
        elif key == "alertConditionSource":
            suggest = "alert_condition_source"
        elif key == "alertConditionSourceUseRegexp":
            suggest = "alert_condition_source_use_regexp"
        elif key == "alertLabels":
            suggest = "alert_labels"
        elif key == "alertPayloads":
            suggest = "alert_payloads"
        elif key == "alertQueryPayload":
            suggest = "alert_query_payload"
        elif key == "alertSources":
            suggest = "alert_sources"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowAlertTriggerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowAlertTriggerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowAlertTriggerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: Optional[str] = None,
                 alert_condition_label: Optional[str] = None,
                 alert_condition_label_use_regexp: Optional[bool] = None,
                 alert_condition_payload: Optional[str] = None,
                 alert_condition_payload_use_regexp: Optional[bool] = None,
                 alert_condition_source: Optional[str] = None,
                 alert_condition_source_use_regexp: Optional[bool] = None,
                 alert_labels: Optional[Sequence[str]] = None,
                 alert_payloads: Optional[Sequence[str]] = None,
                 alert_query_payload: Optional[str] = None,
                 alert_sources: Optional[Sequence[str]] = None,
                 trigger_type: Optional[str] = None,
                 triggers: Optional[Sequence[str]] = None):
        """
        :param str alert_condition: Value must be one off `ALL`, `ANY`, `NONE`.
        :param str alert_condition_label: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param bool alert_condition_label_use_regexp: Value must be one of true or false
        :param str alert_condition_payload: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param bool alert_condition_payload_use_regexp: Value must be one of true or false
        :param str alert_condition_source: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param bool alert_condition_source_use_regexp: Value must be one of true or false
        :param str alert_query_payload: You can use jsonpath syntax. eg: $.incident.teams[*]
        :param str trigger_type: Value must be one off `alert`.
        :param Sequence[str] triggers: Actions that trigger the workflow. Value must be one of `alert_created`.
        """
        if alert_condition is not None:
            pulumi.set(__self__, "alert_condition", alert_condition)
        if alert_condition_label is not None:
            pulumi.set(__self__, "alert_condition_label", alert_condition_label)
        if alert_condition_label_use_regexp is not None:
            pulumi.set(__self__, "alert_condition_label_use_regexp", alert_condition_label_use_regexp)
        if alert_condition_payload is not None:
            pulumi.set(__self__, "alert_condition_payload", alert_condition_payload)
        if alert_condition_payload_use_regexp is not None:
            pulumi.set(__self__, "alert_condition_payload_use_regexp", alert_condition_payload_use_regexp)
        if alert_condition_source is not None:
            pulumi.set(__self__, "alert_condition_source", alert_condition_source)
        if alert_condition_source_use_regexp is not None:
            pulumi.set(__self__, "alert_condition_source_use_regexp", alert_condition_source_use_regexp)
        if alert_labels is not None:
            pulumi.set(__self__, "alert_labels", alert_labels)
        if alert_payloads is not None:
            pulumi.set(__self__, "alert_payloads", alert_payloads)
        if alert_query_payload is not None:
            pulumi.set(__self__, "alert_query_payload", alert_query_payload)
        if alert_sources is not None:
            pulumi.set(__self__, "alert_sources", alert_sources)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> Optional[str]:
        """
        Value must be one off `ALL`, `ANY`, `NONE`.
        """
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="alertConditionLabel")
    def alert_condition_label(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "alert_condition_label")

    @property
    @pulumi.getter(name="alertConditionLabelUseRegexp")
    def alert_condition_label_use_regexp(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "alert_condition_label_use_regexp")

    @property
    @pulumi.getter(name="alertConditionPayload")
    def alert_condition_payload(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "alert_condition_payload")

    @property
    @pulumi.getter(name="alertConditionPayloadUseRegexp")
    def alert_condition_payload_use_regexp(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "alert_condition_payload_use_regexp")

    @property
    @pulumi.getter(name="alertConditionSource")
    def alert_condition_source(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "alert_condition_source")

    @property
    @pulumi.getter(name="alertConditionSourceUseRegexp")
    def alert_condition_source_use_regexp(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "alert_condition_source_use_regexp")

    @property
    @pulumi.getter(name="alertLabels")
    def alert_labels(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "alert_labels")

    @property
    @pulumi.getter(name="alertPayloads")
    def alert_payloads(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "alert_payloads")

    @property
    @pulumi.getter(name="alertQueryPayload")
    def alert_query_payload(self) -> Optional[str]:
        """
        You can use jsonpath syntax. eg: $.incident.teams[*]
        """
        return pulumi.get(self, "alert_query_payload")

    @property
    @pulumi.getter(name="alertSources")
    def alert_sources(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "alert_sources")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[str]:
        """
        Value must be one off `alert`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence[str]]:
        """
        Actions that trigger the workflow. Value must be one of `alert_created`.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class WorkflowIncidentTriggerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentCondition":
            suggest = "incident_condition"
        elif key == "incidentConditionAcknowledgedAt":
            suggest = "incident_condition_acknowledged_at"
        elif key == "incidentConditionCause":
            suggest = "incident_condition_cause"
        elif key == "incidentConditionDetectedAt":
            suggest = "incident_condition_detected_at"
        elif key == "incidentConditionEnvironment":
            suggest = "incident_condition_environment"
        elif key == "incidentConditionFunctionality":
            suggest = "incident_condition_functionality"
        elif key == "incidentConditionGroup":
            suggest = "incident_condition_group"
        elif key == "incidentConditionIncidentRoles":
            suggest = "incident_condition_incident_roles"
        elif key == "incidentConditionIncidentType":
            suggest = "incident_condition_incident_type"
        elif key == "incidentConditionKind":
            suggest = "incident_condition_kind"
        elif key == "incidentConditionMitigatedAt":
            suggest = "incident_condition_mitigated_at"
        elif key == "incidentConditionResolvedAt":
            suggest = "incident_condition_resolved_at"
        elif key == "incidentConditionService":
            suggest = "incident_condition_service"
        elif key == "incidentConditionSeverity":
            suggest = "incident_condition_severity"
        elif key == "incidentConditionStartedAt":
            suggest = "incident_condition_started_at"
        elif key == "incidentConditionStatus":
            suggest = "incident_condition_status"
        elif key == "incidentConditionSummary":
            suggest = "incident_condition_summary"
        elif key == "incidentConditionVisibility":
            suggest = "incident_condition_visibility"
        elif key == "incidentConditionalInactivity":
            suggest = "incident_conditional_inactivity"
        elif key == "incidentInactivityDuration":
            suggest = "incident_inactivity_duration"
        elif key == "incidentKinds":
            suggest = "incident_kinds"
        elif key == "incidentPostMortemConditionCause":
            suggest = "incident_post_mortem_condition_cause"
        elif key == "incidentStatuses":
            suggest = "incident_statuses"
        elif key == "incidentVisibilities":
            suggest = "incident_visibilities"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowIncidentTriggerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowIncidentTriggerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowIncidentTriggerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_condition: Optional[str] = None,
                 incident_condition_acknowledged_at: Optional[str] = None,
                 incident_condition_cause: Optional[str] = None,
                 incident_condition_detected_at: Optional[str] = None,
                 incident_condition_environment: Optional[str] = None,
                 incident_condition_functionality: Optional[str] = None,
                 incident_condition_group: Optional[str] = None,
                 incident_condition_incident_roles: Optional[str] = None,
                 incident_condition_incident_type: Optional[str] = None,
                 incident_condition_kind: Optional[str] = None,
                 incident_condition_mitigated_at: Optional[str] = None,
                 incident_condition_resolved_at: Optional[str] = None,
                 incident_condition_service: Optional[str] = None,
                 incident_condition_severity: Optional[str] = None,
                 incident_condition_started_at: Optional[str] = None,
                 incident_condition_status: Optional[str] = None,
                 incident_condition_summary: Optional[str] = None,
                 incident_condition_visibility: Optional[str] = None,
                 incident_conditional_inactivity: Optional[str] = None,
                 incident_inactivity_duration: Optional[str] = None,
                 incident_kinds: Optional[Sequence[str]] = None,
                 incident_post_mortem_condition_cause: Optional[str] = None,
                 incident_statuses: Optional[Sequence[str]] = None,
                 incident_visibilities: Optional[Sequence[str]] = None,
                 trigger_type: Optional[str] = None,
                 triggers: Optional[Sequence[str]] = None):
        """
        :param str incident_condition: Value must be one off `ALL`, `ANY`, `NONE`.
        :param str incident_condition_cause: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_environment: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_functionality: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_group: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_incident_roles: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_incident_type: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_kind: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_service: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_severity: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_status: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_visibility: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_inactivity_duration: ex. 10 min, 1h, 3 days, 2 weeks
        :param Sequence[str] incident_kinds: Value must be one of `test`, `test_sub`, `example`, `example_sub`, `normal`, `normal_sub`, `backfilled`, `scheduled`.
        :param str incident_post_mortem_condition_cause: [DEPRECATED] Use incident*condition*cause instead. Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param Sequence[str] incident_statuses: Value must be one of `in_triage`, `started`, `detected`, `acknowledged`, `mitigated`, `resolved`, `cancelled`, `scheduled`, `in_progress`, `completed`.
        :param str trigger_type: Value must be one off `incident`.
        :param Sequence[str] triggers: Actions that trigger the workflow. One of custom*fields.\\n\\n.updated, incident*in*triage, incident*created, incident*started, incident*updated, title*updated, summary*updated, status*updated, severity*updated, environments*added, environments*removed, environments*updated, incident*types*added, incident*types*removed, incident*types*updated, services*added, services*removed, services*updated, visibility*updated, functionalities*added, functionalities*removed, functionalities*updated, teams*added, teams*removed, teams*updated, causes*added, causes*removed, causes*updated, timeline*updated, status*page*timeline*updated, role*assignments*updated, role*assignments*added, role*assignments*removed, slack*command, slack*channel*created, slack*channel*converted, subscribers*updated, subscribers*added, subscribers*removed, user*joined*slack*channel, user*left*slack*channel
        """
        if incident_condition is not None:
            pulumi.set(__self__, "incident_condition", incident_condition)
        if incident_condition_acknowledged_at is not None:
            pulumi.set(__self__, "incident_condition_acknowledged_at", incident_condition_acknowledged_at)
        if incident_condition_cause is not None:
            pulumi.set(__self__, "incident_condition_cause", incident_condition_cause)
        if incident_condition_detected_at is not None:
            pulumi.set(__self__, "incident_condition_detected_at", incident_condition_detected_at)
        if incident_condition_environment is not None:
            pulumi.set(__self__, "incident_condition_environment", incident_condition_environment)
        if incident_condition_functionality is not None:
            pulumi.set(__self__, "incident_condition_functionality", incident_condition_functionality)
        if incident_condition_group is not None:
            pulumi.set(__self__, "incident_condition_group", incident_condition_group)
        if incident_condition_incident_roles is not None:
            pulumi.set(__self__, "incident_condition_incident_roles", incident_condition_incident_roles)
        if incident_condition_incident_type is not None:
            pulumi.set(__self__, "incident_condition_incident_type", incident_condition_incident_type)
        if incident_condition_kind is not None:
            pulumi.set(__self__, "incident_condition_kind", incident_condition_kind)
        if incident_condition_mitigated_at is not None:
            pulumi.set(__self__, "incident_condition_mitigated_at", incident_condition_mitigated_at)
        if incident_condition_resolved_at is not None:
            pulumi.set(__self__, "incident_condition_resolved_at", incident_condition_resolved_at)
        if incident_condition_service is not None:
            pulumi.set(__self__, "incident_condition_service", incident_condition_service)
        if incident_condition_severity is not None:
            pulumi.set(__self__, "incident_condition_severity", incident_condition_severity)
        if incident_condition_started_at is not None:
            pulumi.set(__self__, "incident_condition_started_at", incident_condition_started_at)
        if incident_condition_status is not None:
            pulumi.set(__self__, "incident_condition_status", incident_condition_status)
        if incident_condition_summary is not None:
            pulumi.set(__self__, "incident_condition_summary", incident_condition_summary)
        if incident_condition_visibility is not None:
            pulumi.set(__self__, "incident_condition_visibility", incident_condition_visibility)
        if incident_conditional_inactivity is not None:
            pulumi.set(__self__, "incident_conditional_inactivity", incident_conditional_inactivity)
        if incident_inactivity_duration is not None:
            pulumi.set(__self__, "incident_inactivity_duration", incident_inactivity_duration)
        if incident_kinds is not None:
            pulumi.set(__self__, "incident_kinds", incident_kinds)
        if incident_post_mortem_condition_cause is not None:
            pulumi.set(__self__, "incident_post_mortem_condition_cause", incident_post_mortem_condition_cause)
        if incident_statuses is not None:
            pulumi.set(__self__, "incident_statuses", incident_statuses)
        if incident_visibilities is not None:
            pulumi.set(__self__, "incident_visibilities", incident_visibilities)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="incidentCondition")
    def incident_condition(self) -> Optional[str]:
        """
        Value must be one off `ALL`, `ANY`, `NONE`.
        """
        return pulumi.get(self, "incident_condition")

    @property
    @pulumi.getter(name="incidentConditionAcknowledgedAt")
    def incident_condition_acknowledged_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_acknowledged_at")

    @property
    @pulumi.getter(name="incidentConditionCause")
    def incident_condition_cause(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_cause")

    @property
    @pulumi.getter(name="incidentConditionDetectedAt")
    def incident_condition_detected_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_detected_at")

    @property
    @pulumi.getter(name="incidentConditionEnvironment")
    def incident_condition_environment(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_environment")

    @property
    @pulumi.getter(name="incidentConditionFunctionality")
    def incident_condition_functionality(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_functionality")

    @property
    @pulumi.getter(name="incidentConditionGroup")
    def incident_condition_group(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_group")

    @property
    @pulumi.getter(name="incidentConditionIncidentRoles")
    def incident_condition_incident_roles(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_incident_roles")

    @property
    @pulumi.getter(name="incidentConditionIncidentType")
    def incident_condition_incident_type(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_incident_type")

    @property
    @pulumi.getter(name="incidentConditionKind")
    def incident_condition_kind(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_kind")

    @property
    @pulumi.getter(name="incidentConditionMitigatedAt")
    def incident_condition_mitigated_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_mitigated_at")

    @property
    @pulumi.getter(name="incidentConditionResolvedAt")
    def incident_condition_resolved_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_resolved_at")

    @property
    @pulumi.getter(name="incidentConditionService")
    def incident_condition_service(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_service")

    @property
    @pulumi.getter(name="incidentConditionSeverity")
    def incident_condition_severity(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_severity")

    @property
    @pulumi.getter(name="incidentConditionStartedAt")
    def incident_condition_started_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_started_at")

    @property
    @pulumi.getter(name="incidentConditionStatus")
    def incident_condition_status(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_status")

    @property
    @pulumi.getter(name="incidentConditionSummary")
    def incident_condition_summary(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_summary")

    @property
    @pulumi.getter(name="incidentConditionVisibility")
    def incident_condition_visibility(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_visibility")

    @property
    @pulumi.getter(name="incidentConditionalInactivity")
    def incident_conditional_inactivity(self) -> Optional[str]:
        return pulumi.get(self, "incident_conditional_inactivity")

    @property
    @pulumi.getter(name="incidentInactivityDuration")
    def incident_inactivity_duration(self) -> Optional[str]:
        """
        ex. 10 min, 1h, 3 days, 2 weeks
        """
        return pulumi.get(self, "incident_inactivity_duration")

    @property
    @pulumi.getter(name="incidentKinds")
    def incident_kinds(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `test`, `test_sub`, `example`, `example_sub`, `normal`, `normal_sub`, `backfilled`, `scheduled`.
        """
        return pulumi.get(self, "incident_kinds")

    @property
    @pulumi.getter(name="incidentPostMortemConditionCause")
    def incident_post_mortem_condition_cause(self) -> Optional[str]:
        """
        [DEPRECATED] Use incident*condition*cause instead. Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_post_mortem_condition_cause")

    @property
    @pulumi.getter(name="incidentStatuses")
    def incident_statuses(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `in_triage`, `started`, `detected`, `acknowledged`, `mitigated`, `resolved`, `cancelled`, `scheduled`, `in_progress`, `completed`.
        """
        return pulumi.get(self, "incident_statuses")

    @property
    @pulumi.getter(name="incidentVisibilities")
    def incident_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "incident_visibilities")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[str]:
        """
        Value must be one off `incident`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence[str]]:
        """
        Actions that trigger the workflow. One of custom*fields.\\n\\n.updated, incident*in*triage, incident*created, incident*started, incident*updated, title*updated, summary*updated, status*updated, severity*updated, environments*added, environments*removed, environments*updated, incident*types*added, incident*types*removed, incident*types*updated, services*added, services*removed, services*updated, visibility*updated, functionalities*added, functionalities*removed, functionalities*updated, teams*added, teams*removed, teams*updated, causes*added, causes*removed, causes*updated, timeline*updated, status*page*timeline*updated, role*assignments*updated, role*assignments*added, role*assignments*removed, slack*command, slack*channel*created, slack*channel*converted, subscribers*updated, subscribers*added, subscribers*removed, user*joined*slack*channel, user*left*slack*channel
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class WorkflowPostMortemTriggerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentCondition":
            suggest = "incident_condition"
        elif key == "incidentConditionAcknowledgedAt":
            suggest = "incident_condition_acknowledged_at"
        elif key == "incidentConditionCause":
            suggest = "incident_condition_cause"
        elif key == "incidentConditionDetectedAt":
            suggest = "incident_condition_detected_at"
        elif key == "incidentConditionEnvironment":
            suggest = "incident_condition_environment"
        elif key == "incidentConditionFunctionality":
            suggest = "incident_condition_functionality"
        elif key == "incidentConditionGroup":
            suggest = "incident_condition_group"
        elif key == "incidentConditionIncidentRoles":
            suggest = "incident_condition_incident_roles"
        elif key == "incidentConditionIncidentType":
            suggest = "incident_condition_incident_type"
        elif key == "incidentConditionKind":
            suggest = "incident_condition_kind"
        elif key == "incidentConditionMitigatedAt":
            suggest = "incident_condition_mitigated_at"
        elif key == "incidentConditionResolvedAt":
            suggest = "incident_condition_resolved_at"
        elif key == "incidentConditionService":
            suggest = "incident_condition_service"
        elif key == "incidentConditionSeverity":
            suggest = "incident_condition_severity"
        elif key == "incidentConditionStartedAt":
            suggest = "incident_condition_started_at"
        elif key == "incidentConditionStatus":
            suggest = "incident_condition_status"
        elif key == "incidentConditionSummary":
            suggest = "incident_condition_summary"
        elif key == "incidentConditionVisibility":
            suggest = "incident_condition_visibility"
        elif key == "incidentConditionalInactivity":
            suggest = "incident_conditional_inactivity"
        elif key == "incidentInactivityDuration":
            suggest = "incident_inactivity_duration"
        elif key == "incidentKinds":
            suggest = "incident_kinds"
        elif key == "incidentPostMortemCondition":
            suggest = "incident_post_mortem_condition"
        elif key == "incidentPostMortemConditionCause":
            suggest = "incident_post_mortem_condition_cause"
        elif key == "incidentPostMortemConditionStatus":
            suggest = "incident_post_mortem_condition_status"
        elif key == "incidentPostMortemStatuses":
            suggest = "incident_post_mortem_statuses"
        elif key == "incidentStatuses":
            suggest = "incident_statuses"
        elif key == "incidentVisibilities":
            suggest = "incident_visibilities"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowPostMortemTriggerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowPostMortemTriggerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowPostMortemTriggerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_condition: Optional[str] = None,
                 incident_condition_acknowledged_at: Optional[str] = None,
                 incident_condition_cause: Optional[str] = None,
                 incident_condition_detected_at: Optional[str] = None,
                 incident_condition_environment: Optional[str] = None,
                 incident_condition_functionality: Optional[str] = None,
                 incident_condition_group: Optional[str] = None,
                 incident_condition_incident_roles: Optional[str] = None,
                 incident_condition_incident_type: Optional[str] = None,
                 incident_condition_kind: Optional[str] = None,
                 incident_condition_mitigated_at: Optional[str] = None,
                 incident_condition_resolved_at: Optional[str] = None,
                 incident_condition_service: Optional[str] = None,
                 incident_condition_severity: Optional[str] = None,
                 incident_condition_started_at: Optional[str] = None,
                 incident_condition_status: Optional[str] = None,
                 incident_condition_summary: Optional[str] = None,
                 incident_condition_visibility: Optional[str] = None,
                 incident_conditional_inactivity: Optional[str] = None,
                 incident_inactivity_duration: Optional[str] = None,
                 incident_kinds: Optional[Sequence[str]] = None,
                 incident_post_mortem_condition: Optional[str] = None,
                 incident_post_mortem_condition_cause: Optional[str] = None,
                 incident_post_mortem_condition_status: Optional[str] = None,
                 incident_post_mortem_statuses: Optional[Sequence[str]] = None,
                 incident_statuses: Optional[Sequence[str]] = None,
                 incident_visibilities: Optional[Sequence[str]] = None,
                 trigger_type: Optional[str] = None,
                 triggers: Optional[Sequence[str]] = None):
        """
        :param str incident_condition: Value must be one off `ALL`, `ANY`, `NONE`.
        :param str incident_condition_cause: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_environment: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_functionality: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_group: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_incident_roles: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_incident_type: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_kind: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_service: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_severity: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_status: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_condition_visibility: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_inactivity_duration: ex. 10 min, 1h, 3 days, 2 weeks
        :param Sequence[str] incident_kinds: Value must be one of `test`, `test_sub`, `example`, `example_sub`, `normal`, `normal_sub`, `backfilled`, `scheduled`.
        :param str incident_post_mortem_condition: Value must be one off `ALL`, `ANY`, `NONE`.
        :param str incident_post_mortem_condition_cause: [DEPRECATED] Use incident*condition*cause instead. Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param str incident_post_mortem_condition_status: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param Sequence[str] incident_post_mortem_statuses: Value must be one of `draft`, `published`.
        :param Sequence[str] incident_statuses: Value must be one of `in_triage`, `started`, `detected`, `acknowledged`, `mitigated`, `resolved`, `cancelled`, `scheduled`, `in_progress`, `completed`.
        :param str trigger_type: Value must be one off `post_mortem`.
        :param Sequence[str] triggers: Actions that trigger the workflow. One of custom*fields.\\n\\n.updated, post*mortem*created, post*mortem*updated, status*updated, slack_command
        """
        if incident_condition is not None:
            pulumi.set(__self__, "incident_condition", incident_condition)
        if incident_condition_acknowledged_at is not None:
            pulumi.set(__self__, "incident_condition_acknowledged_at", incident_condition_acknowledged_at)
        if incident_condition_cause is not None:
            pulumi.set(__self__, "incident_condition_cause", incident_condition_cause)
        if incident_condition_detected_at is not None:
            pulumi.set(__self__, "incident_condition_detected_at", incident_condition_detected_at)
        if incident_condition_environment is not None:
            pulumi.set(__self__, "incident_condition_environment", incident_condition_environment)
        if incident_condition_functionality is not None:
            pulumi.set(__self__, "incident_condition_functionality", incident_condition_functionality)
        if incident_condition_group is not None:
            pulumi.set(__self__, "incident_condition_group", incident_condition_group)
        if incident_condition_incident_roles is not None:
            pulumi.set(__self__, "incident_condition_incident_roles", incident_condition_incident_roles)
        if incident_condition_incident_type is not None:
            pulumi.set(__self__, "incident_condition_incident_type", incident_condition_incident_type)
        if incident_condition_kind is not None:
            pulumi.set(__self__, "incident_condition_kind", incident_condition_kind)
        if incident_condition_mitigated_at is not None:
            pulumi.set(__self__, "incident_condition_mitigated_at", incident_condition_mitigated_at)
        if incident_condition_resolved_at is not None:
            pulumi.set(__self__, "incident_condition_resolved_at", incident_condition_resolved_at)
        if incident_condition_service is not None:
            pulumi.set(__self__, "incident_condition_service", incident_condition_service)
        if incident_condition_severity is not None:
            pulumi.set(__self__, "incident_condition_severity", incident_condition_severity)
        if incident_condition_started_at is not None:
            pulumi.set(__self__, "incident_condition_started_at", incident_condition_started_at)
        if incident_condition_status is not None:
            pulumi.set(__self__, "incident_condition_status", incident_condition_status)
        if incident_condition_summary is not None:
            pulumi.set(__self__, "incident_condition_summary", incident_condition_summary)
        if incident_condition_visibility is not None:
            pulumi.set(__self__, "incident_condition_visibility", incident_condition_visibility)
        if incident_conditional_inactivity is not None:
            pulumi.set(__self__, "incident_conditional_inactivity", incident_conditional_inactivity)
        if incident_inactivity_duration is not None:
            pulumi.set(__self__, "incident_inactivity_duration", incident_inactivity_duration)
        if incident_kinds is not None:
            pulumi.set(__self__, "incident_kinds", incident_kinds)
        if incident_post_mortem_condition is not None:
            pulumi.set(__self__, "incident_post_mortem_condition", incident_post_mortem_condition)
        if incident_post_mortem_condition_cause is not None:
            pulumi.set(__self__, "incident_post_mortem_condition_cause", incident_post_mortem_condition_cause)
        if incident_post_mortem_condition_status is not None:
            pulumi.set(__self__, "incident_post_mortem_condition_status", incident_post_mortem_condition_status)
        if incident_post_mortem_statuses is not None:
            pulumi.set(__self__, "incident_post_mortem_statuses", incident_post_mortem_statuses)
        if incident_statuses is not None:
            pulumi.set(__self__, "incident_statuses", incident_statuses)
        if incident_visibilities is not None:
            pulumi.set(__self__, "incident_visibilities", incident_visibilities)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="incidentCondition")
    def incident_condition(self) -> Optional[str]:
        """
        Value must be one off `ALL`, `ANY`, `NONE`.
        """
        return pulumi.get(self, "incident_condition")

    @property
    @pulumi.getter(name="incidentConditionAcknowledgedAt")
    def incident_condition_acknowledged_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_acknowledged_at")

    @property
    @pulumi.getter(name="incidentConditionCause")
    def incident_condition_cause(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_cause")

    @property
    @pulumi.getter(name="incidentConditionDetectedAt")
    def incident_condition_detected_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_detected_at")

    @property
    @pulumi.getter(name="incidentConditionEnvironment")
    def incident_condition_environment(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_environment")

    @property
    @pulumi.getter(name="incidentConditionFunctionality")
    def incident_condition_functionality(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_functionality")

    @property
    @pulumi.getter(name="incidentConditionGroup")
    def incident_condition_group(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_group")

    @property
    @pulumi.getter(name="incidentConditionIncidentRoles")
    def incident_condition_incident_roles(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_incident_roles")

    @property
    @pulumi.getter(name="incidentConditionIncidentType")
    def incident_condition_incident_type(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_incident_type")

    @property
    @pulumi.getter(name="incidentConditionKind")
    def incident_condition_kind(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_kind")

    @property
    @pulumi.getter(name="incidentConditionMitigatedAt")
    def incident_condition_mitigated_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_mitigated_at")

    @property
    @pulumi.getter(name="incidentConditionResolvedAt")
    def incident_condition_resolved_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_resolved_at")

    @property
    @pulumi.getter(name="incidentConditionService")
    def incident_condition_service(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_service")

    @property
    @pulumi.getter(name="incidentConditionSeverity")
    def incident_condition_severity(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_severity")

    @property
    @pulumi.getter(name="incidentConditionStartedAt")
    def incident_condition_started_at(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_started_at")

    @property
    @pulumi.getter(name="incidentConditionStatus")
    def incident_condition_status(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_status")

    @property
    @pulumi.getter(name="incidentConditionSummary")
    def incident_condition_summary(self) -> Optional[str]:
        return pulumi.get(self, "incident_condition_summary")

    @property
    @pulumi.getter(name="incidentConditionVisibility")
    def incident_condition_visibility(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_condition_visibility")

    @property
    @pulumi.getter(name="incidentConditionalInactivity")
    def incident_conditional_inactivity(self) -> Optional[str]:
        return pulumi.get(self, "incident_conditional_inactivity")

    @property
    @pulumi.getter(name="incidentInactivityDuration")
    def incident_inactivity_duration(self) -> Optional[str]:
        """
        ex. 10 min, 1h, 3 days, 2 weeks
        """
        return pulumi.get(self, "incident_inactivity_duration")

    @property
    @pulumi.getter(name="incidentKinds")
    def incident_kinds(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `test`, `test_sub`, `example`, `example_sub`, `normal`, `normal_sub`, `backfilled`, `scheduled`.
        """
        return pulumi.get(self, "incident_kinds")

    @property
    @pulumi.getter(name="incidentPostMortemCondition")
    def incident_post_mortem_condition(self) -> Optional[str]:
        """
        Value must be one off `ALL`, `ANY`, `NONE`.
        """
        return pulumi.get(self, "incident_post_mortem_condition")

    @property
    @pulumi.getter(name="incidentPostMortemConditionCause")
    def incident_post_mortem_condition_cause(self) -> Optional[str]:
        """
        [DEPRECATED] Use incident*condition*cause instead. Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_post_mortem_condition_cause")

    @property
    @pulumi.getter(name="incidentPostMortemConditionStatus")
    def incident_post_mortem_condition_status(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "incident_post_mortem_condition_status")

    @property
    @pulumi.getter(name="incidentPostMortemStatuses")
    def incident_post_mortem_statuses(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `draft`, `published`.
        """
        return pulumi.get(self, "incident_post_mortem_statuses")

    @property
    @pulumi.getter(name="incidentStatuses")
    def incident_statuses(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `in_triage`, `started`, `detected`, `acknowledged`, `mitigated`, `resolved`, `cancelled`, `scheduled`, `in_progress`, `completed`.
        """
        return pulumi.get(self, "incident_statuses")

    @property
    @pulumi.getter(name="incidentVisibilities")
    def incident_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "incident_visibilities")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[str]:
        """
        Value must be one off `post_mortem`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence[str]]:
        """
        Actions that trigger the workflow. One of custom*fields.\\n\\n.updated, post*mortem*created, post*mortem*updated, status*updated, slack_command
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class WorkflowPulseTriggerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pulseCondition":
            suggest = "pulse_condition"
        elif key == "pulseConditionLabel":
            suggest = "pulse_condition_label"
        elif key == "pulseConditionLabelUseRegexp":
            suggest = "pulse_condition_label_use_regexp"
        elif key == "pulseConditionPayload":
            suggest = "pulse_condition_payload"
        elif key == "pulseConditionPayloadUseRegexp":
            suggest = "pulse_condition_payload_use_regexp"
        elif key == "pulseConditionSource":
            suggest = "pulse_condition_source"
        elif key == "pulseConditionSourceUseRegexp":
            suggest = "pulse_condition_source_use_regexp"
        elif key == "pulseLabels":
            suggest = "pulse_labels"
        elif key == "pulsePayloads":
            suggest = "pulse_payloads"
        elif key == "pulseQueryPayload":
            suggest = "pulse_query_payload"
        elif key == "pulseSources":
            suggest = "pulse_sources"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowPulseTriggerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowPulseTriggerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowPulseTriggerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pulse_condition: Optional[str] = None,
                 pulse_condition_label: Optional[str] = None,
                 pulse_condition_label_use_regexp: Optional[bool] = None,
                 pulse_condition_payload: Optional[str] = None,
                 pulse_condition_payload_use_regexp: Optional[bool] = None,
                 pulse_condition_source: Optional[str] = None,
                 pulse_condition_source_use_regexp: Optional[bool] = None,
                 pulse_labels: Optional[Sequence[str]] = None,
                 pulse_payloads: Optional[Sequence[str]] = None,
                 pulse_query_payload: Optional[str] = None,
                 pulse_sources: Optional[Sequence[str]] = None,
                 trigger_type: Optional[str] = None,
                 triggers: Optional[Sequence[str]] = None):
        """
        :param str pulse_condition: Value must be one off `ALL`, `ANY`, `NONE`.
        :param str pulse_condition_label: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param bool pulse_condition_label_use_regexp: Value must be one of true or false
        :param str pulse_condition_payload: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param bool pulse_condition_payload_use_regexp: Value must be one of true or false
        :param str pulse_condition_source: Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        :param bool pulse_condition_source_use_regexp: Value must be one of true or false
        :param str pulse_query_payload: You can use jsonpath syntax. eg: $.incident.teams[*]
        :param str trigger_type: Value must be one off `pulse`.
        :param Sequence[str] triggers: Actions that trigger the workflow. Value must be one of `pulse_created`.
        """
        if pulse_condition is not None:
            pulumi.set(__self__, "pulse_condition", pulse_condition)
        if pulse_condition_label is not None:
            pulumi.set(__self__, "pulse_condition_label", pulse_condition_label)
        if pulse_condition_label_use_regexp is not None:
            pulumi.set(__self__, "pulse_condition_label_use_regexp", pulse_condition_label_use_regexp)
        if pulse_condition_payload is not None:
            pulumi.set(__self__, "pulse_condition_payload", pulse_condition_payload)
        if pulse_condition_payload_use_regexp is not None:
            pulumi.set(__self__, "pulse_condition_payload_use_regexp", pulse_condition_payload_use_regexp)
        if pulse_condition_source is not None:
            pulumi.set(__self__, "pulse_condition_source", pulse_condition_source)
        if pulse_condition_source_use_regexp is not None:
            pulumi.set(__self__, "pulse_condition_source_use_regexp", pulse_condition_source_use_regexp)
        if pulse_labels is not None:
            pulumi.set(__self__, "pulse_labels", pulse_labels)
        if pulse_payloads is not None:
            pulumi.set(__self__, "pulse_payloads", pulse_payloads)
        if pulse_query_payload is not None:
            pulumi.set(__self__, "pulse_query_payload", pulse_query_payload)
        if pulse_sources is not None:
            pulumi.set(__self__, "pulse_sources", pulse_sources)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="pulseCondition")
    def pulse_condition(self) -> Optional[str]:
        """
        Value must be one off `ALL`, `ANY`, `NONE`.
        """
        return pulumi.get(self, "pulse_condition")

    @property
    @pulumi.getter(name="pulseConditionLabel")
    def pulse_condition_label(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "pulse_condition_label")

    @property
    @pulumi.getter(name="pulseConditionLabelUseRegexp")
    def pulse_condition_label_use_regexp(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "pulse_condition_label_use_regexp")

    @property
    @pulumi.getter(name="pulseConditionPayload")
    def pulse_condition_payload(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "pulse_condition_payload")

    @property
    @pulumi.getter(name="pulseConditionPayloadUseRegexp")
    def pulse_condition_payload_use_regexp(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "pulse_condition_payload_use_regexp")

    @property
    @pulumi.getter(name="pulseConditionSource")
    def pulse_condition_source(self) -> Optional[str]:
        """
        Value must be one off `IS`, `ANY`, `CONTAINS`, `CONTAINS_ALL`, `CONTAINS_NONE`, `NONE`, `SET`, `UNSET`.
        """
        return pulumi.get(self, "pulse_condition_source")

    @property
    @pulumi.getter(name="pulseConditionSourceUseRegexp")
    def pulse_condition_source_use_regexp(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "pulse_condition_source_use_regexp")

    @property
    @pulumi.getter(name="pulseLabels")
    def pulse_labels(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "pulse_labels")

    @property
    @pulumi.getter(name="pulsePayloads")
    def pulse_payloads(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "pulse_payloads")

    @property
    @pulumi.getter(name="pulseQueryPayload")
    def pulse_query_payload(self) -> Optional[str]:
        """
        You can use jsonpath syntax. eg: $.incident.teams[*]
        """
        return pulumi.get(self, "pulse_query_payload")

    @property
    @pulumi.getter(name="pulseSources")
    def pulse_sources(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "pulse_sources")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[str]:
        """
        Value must be one off `pulse`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence[str]]:
        """
        Actions that trigger the workflow. Value must be one of `pulse_created`.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class WorkflowSimpleTriggerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowSimpleTriggerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowSimpleTriggerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowSimpleTriggerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger_type: Optional[str] = None,
                 triggers: Optional[Sequence[str]] = None):
        """
        :param str trigger_type: Value must be one off `simple`.
        :param Sequence[str] triggers: Actions that trigger the workflow. Value must be one of `slack_command`.
        """
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[str]:
        """
        Value must be one off `simple`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence[str]]:
        """
        Actions that trigger the workflow. Value must be one of `slack_command`.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class WorkflowTaskAddActionItemTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedToUser":
            suggest = "assigned_to_user"
        elif key == "assignedToUserId":
            suggest = "assigned_to_user_id"
        elif key == "incidentRoleId":
            suggest = "incident_role_id"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAddActionItemTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAddActionItemTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAddActionItemTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: str,
                 status: str,
                 summary: str,
                 assigned_to_user: Optional[Mapping[str, str]] = None,
                 assigned_to_user_id: Optional[str] = None,
                 description: Optional[str] = None,
                 incident_role_id: Optional[str] = None,
                 kind: Optional[str] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskAddActionItemTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param str priority: The action item priority. Value must be one of `high`, `medium`, `low`.
        :param str status: The action item status. Value must be one of `open`, `in_progress`, `cancelled`, `done`.
        :param str summary: The action item summary
        :param Mapping[str, str] assigned_to_user: Map must contain two fields, `id` and `name`.  The user this action item is assigned to
        :param str assigned_to_user_id: [DEPRECATED] Use assigned*to*user attribute instead. The user id this action item is assigned to
        :param str description: The action item description
        :param str incident_role_id: The role id this action item is associated with
        :param str kind: The action item kind
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "summary", summary)
        if assigned_to_user is not None:
            pulumi.set(__self__, "assigned_to_user", assigned_to_user)
        if assigned_to_user_id is not None:
            pulumi.set(__self__, "assigned_to_user_id", assigned_to_user_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if incident_role_id is not None:
            pulumi.set(__self__, "incident_role_id", incident_role_id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def priority(self) -> str:
        """
        The action item priority. Value must be one of `high`, `medium`, `low`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The action item status. Value must be one of `open`, `in_progress`, `cancelled`, `done`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The action item summary
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="assignedToUser")
    def assigned_to_user(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.  The user this action item is assigned to
        """
        return pulumi.get(self, "assigned_to_user")

    @property
    @pulumi.getter(name="assignedToUserId")
    def assigned_to_user_id(self) -> Optional[str]:
        """
        [DEPRECATED] Use assigned*to*user attribute instead. The user id this action item is assigned to
        """
        return pulumi.get(self, "assigned_to_user_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The action item description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="incidentRoleId")
    def incident_role_id(self) -> Optional[str]:
        """
        The role id this action item is associated with
        """
        return pulumi.get(self, "incident_role_id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        The action item kind
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskAddActionItemTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskAddActionItemTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskAddRoleTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentRoleId":
            suggest = "incident_role_id"
        elif key == "assignedToUser":
            suggest = "assigned_to_user"
        elif key == "assignedToUserId":
            suggest = "assigned_to_user_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAddRoleTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAddRoleTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAddRoleTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_role_id: str,
                 assigned_to_user: Optional[Mapping[str, str]] = None,
                 assigned_to_user_id: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str incident_role_id: The role id to add to the incident
        :param Mapping[str, str] assigned_to_user: Map must contain two fields, `id` and `name`.  The user this role is assigned to
        :param str assigned_to_user_id: [DEPRECATED] Use assigned*to*user attribute instead. The user id this role is assigned to
        """
        pulumi.set(__self__, "incident_role_id", incident_role_id)
        if assigned_to_user is not None:
            pulumi.set(__self__, "assigned_to_user", assigned_to_user)
        if assigned_to_user_id is not None:
            pulumi.set(__self__, "assigned_to_user_id", assigned_to_user_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="incidentRoleId")
    def incident_role_id(self) -> str:
        """
        The role id to add to the incident
        """
        return pulumi.get(self, "incident_role_id")

    @property
    @pulumi.getter(name="assignedToUser")
    def assigned_to_user(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.  The user this role is assigned to
        """
        return pulumi.get(self, "assigned_to_user")

    @property
    @pulumi.getter(name="assignedToUserId")
    def assigned_to_user_id(self) -> Optional[str]:
        """
        [DEPRECATED] Use assigned*to*user attribute instead. The user id this role is assigned to
        """
        return pulumi.get(self, "assigned_to_user_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskAddSlackBookmarkTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "playbookId":
            suggest = "playbook_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAddSlackBookmarkTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAddSlackBookmarkTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAddSlackBookmarkTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Mapping[str, str],
                 emoji: Optional[str] = None,
                 link: Optional[str] = None,
                 playbook_id: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param Mapping[str, str] channel: Map must contain two fields, `id` and `name`.
        :param str emoji: The bookmark emoji
        :param str link: The bookmark link. Required if not a playbook bookmark
        :param str playbook_id: The playbook id if bookmark is of an incident playbook
        :param str title: The bookmark title. Required if not a playbook bookmark
        """
        pulumi.set(__self__, "channel", channel)
        if emoji is not None:
            pulumi.set(__self__, "emoji", emoji)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if playbook_id is not None:
            pulumi.set(__self__, "playbook_id", playbook_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def channel(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter
    def emoji(self) -> Optional[str]:
        """
        The bookmark emoji
        """
        return pulumi.get(self, "emoji")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The bookmark link. Required if not a playbook bookmark
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="playbookId")
    def playbook_id(self) -> Optional[str]:
        """
        The playbook id if bookmark is of an incident playbook
        """
        return pulumi.get(self, "playbook_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The bookmark title. Required if not a playbook bookmark
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskAddTeamTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAddTeamTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAddTeamTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAddTeamTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: str,
                 task_type: Optional[str] = None):
        """
        :param str group_id: The team id
        """
        pulumi.set(__self__, "group_id", group_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        The team id
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskAddToTimelineTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAddToTimelineTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAddToTimelineTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAddToTimelineTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event: str,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskAddToTimelineTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str event: The timeline event description
        :param str url: A URL for the timeline event
        """
        pulumi.set(__self__, "event", event)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def event(self) -> str:
        """
        The timeline event description
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskAddToTimelineTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        A URL for the timeline event
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkflowTaskAddToTimelineTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskArchiveSlackChannelsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskArchiveSlackChannelsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskArchiveSlackChannelsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskArchiveSlackChannelsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channels: Sequence['outputs.WorkflowTaskArchiveSlackChannelsTaskParamsChannel'],
                 task_type: Optional[str] = None):
        pulumi.set(__self__, "channels", channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def channels(self) -> Sequence['outputs.WorkflowTaskArchiveSlackChannelsTaskParamsChannel']:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskArchiveSlackChannelsTaskParamsChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskAttachDatadogDashboardsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAttachDatadogDashboardsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAttachDatadogDashboardsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAttachDatadogDashboardsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Sequence['outputs.WorkflowTaskAttachDatadogDashboardsTaskParamsDashboard'],
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskAttachDatadogDashboardsTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "dashboards", dashboards)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def dashboards(self) -> Sequence['outputs.WorkflowTaskAttachDatadogDashboardsTaskParamsDashboard']:
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskAttachDatadogDashboardsTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskAttachDatadogDashboardsTaskParamsDashboard(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskAttachDatadogDashboardsTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskAutoAssignRoleOpsgenieTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentRoleId":
            suggest = "incident_role_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAutoAssignRoleOpsgenieTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAutoAssignRoleOpsgenieTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAutoAssignRoleOpsgenieTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_role_id: str,
                 schedule: Mapping[str, str],
                 task_type: Optional[str] = None):
        """
        :param str incident_role_id: The role id
        :param Mapping[str, str] schedule: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "incident_role_id", incident_role_id)
        pulumi.set(__self__, "schedule", schedule)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="incidentRoleId")
    def incident_role_id(self) -> str:
        """
        The role id
        """
        return pulumi.get(self, "incident_role_id")

    @property
    @pulumi.getter
    def schedule(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskAutoAssignRolePagerdutyTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentRoleId":
            suggest = "incident_role_id"
        elif key == "escalationPolicy":
            suggest = "escalation_policy"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAutoAssignRolePagerdutyTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAutoAssignRolePagerdutyTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAutoAssignRolePagerdutyTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_role_id: str,
                 escalation_policy: Optional[Mapping[str, str]] = None,
                 schedule: Optional[Mapping[str, str]] = None,
                 service: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None):
        """
        :param str incident_role_id: The role id
        :param Mapping[str, str] escalation_policy: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] schedule: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] service: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "incident_role_id", incident_role_id)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="incidentRoleId")
    def incident_role_id(self) -> str:
        """
        The role id
        """
        return pulumi.get(self, "incident_role_id")

    @property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "escalation_policy")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def service(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskAutoAssignRoleRootlyTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentRoleId":
            suggest = "incident_role_id"
        elif key == "escalationPolicyTarget":
            suggest = "escalation_policy_target"
        elif key == "groupTarget":
            suggest = "group_target"
        elif key == "scheduleTarget":
            suggest = "schedule_target"
        elif key == "serviceTarget":
            suggest = "service_target"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "userTarget":
            suggest = "user_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAutoAssignRoleRootlyTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAutoAssignRoleRootlyTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAutoAssignRoleRootlyTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_role_id: str,
                 escalation_policy_target: Optional[Mapping[str, str]] = None,
                 group_target: Optional[Mapping[str, str]] = None,
                 schedule_target: Optional[Mapping[str, str]] = None,
                 service_target: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 user_target: Optional[Mapping[str, str]] = None):
        """
        :param str incident_role_id: The role id
        :param Mapping[str, str] escalation_policy_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] group_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] schedule_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] service_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] user_target: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "incident_role_id", incident_role_id)
        if escalation_policy_target is not None:
            pulumi.set(__self__, "escalation_policy_target", escalation_policy_target)
        if group_target is not None:
            pulumi.set(__self__, "group_target", group_target)
        if schedule_target is not None:
            pulumi.set(__self__, "schedule_target", schedule_target)
        if service_target is not None:
            pulumi.set(__self__, "service_target", service_target)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if user_target is not None:
            pulumi.set(__self__, "user_target", user_target)

    @property
    @pulumi.getter(name="incidentRoleId")
    def incident_role_id(self) -> str:
        """
        The role id
        """
        return pulumi.get(self, "incident_role_id")

    @property
    @pulumi.getter(name="escalationPolicyTarget")
    def escalation_policy_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "escalation_policy_target")

    @property
    @pulumi.getter(name="groupTarget")
    def group_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "group_target")

    @property
    @pulumi.getter(name="scheduleTarget")
    def schedule_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "schedule_target")

    @property
    @pulumi.getter(name="serviceTarget")
    def service_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "service_target")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="userTarget")
    def user_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "user_target")


@pulumi.output_type
class WorkflowTaskAutoAssignRoleVictorOpsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentRoleId":
            suggest = "incident_role_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskAutoAssignRoleVictorOpsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskAutoAssignRoleVictorOpsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskAutoAssignRoleVictorOpsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_role_id: str,
                 team: Mapping[str, str],
                 task_type: Optional[str] = None):
        """
        :param str incident_role_id: The role id
        :param Mapping[str, str] team: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "incident_role_id", incident_role_id)
        pulumi.set(__self__, "team", team)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="incidentRoleId")
    def incident_role_id(self) -> str:
        """
        The role id
        """
        return pulumi.get(self, "incident_role_id")

    @property
    @pulumi.getter
    def team(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "team")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCallPeopleTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumbers":
            suggest = "phone_numbers"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCallPeopleTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCallPeopleTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCallPeopleTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 name: str,
                 phone_numbers: Sequence[str],
                 task_type: Optional[str] = None):
        """
        :param str content: The message to be read by text-to-voice
        :param str name: The name
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_numbers", phone_numbers)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The message to be read by text-to-voice
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumbers")
    def phone_numbers(self) -> Sequence[str]:
        return pulumi.get(self, "phone_numbers")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskChangeSlackChannelPrivacyTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskChangeSlackChannelPrivacyTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskChangeSlackChannelPrivacyTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskChangeSlackChannelPrivacyTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 privacy: str,
                 channel: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None):
        """
        :param str privacy: Value must be one of `private`, `public`.
        :param Mapping[str, str] channel: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "privacy", privacy)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def privacy(self) -> str:
        """
        Value must be one of `private`, `public`.
        """
        return pulumi.get(self, "privacy")

    @property
    @pulumi.getter
    def channel(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateAirtableTableRecordTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateAirtableTableRecordTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateAirtableTableRecordTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateAirtableTableRecordTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base: Mapping[str, str],
                 table: Mapping[str, str],
                 custom_fields_mapping: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] base: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] table: Map must contain two fields, `id` and `name`.
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        pulumi.set(__self__, "base", base)
        pulumi.set(__self__, "table", table)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def base(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def table(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateAsanaSubtaskTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentTaskId":
            suggest = "parent_task_id"
        elif key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "dependencyDirection":
            suggest = "dependency_direction"
        elif key == "dependentTaskIds":
            suggest = "dependent_task_ids"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateAsanaSubtaskTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateAsanaSubtaskTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateAsanaSubtaskTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completion: Mapping[str, str],
                 parent_task_id: str,
                 title: str,
                 assign_user_email: Optional[str] = None,
                 custom_fields_mapping: Optional[str] = None,
                 dependency_direction: Optional[str] = None,
                 dependent_task_ids: Optional[Sequence[str]] = None,
                 due_date: Optional[str] = None,
                 notes: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`.
        :param str parent_task_id: The parent task id
        :param str title: The subtask title
        :param str assign_user_email: The assigned user's email
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str dependency_direction: Value must be one of `blocking`, `blocked_by`.
        :param Sequence[str] dependent_task_ids: Dependent task ids. Supports liquid syntax
        :param str due_date: The due date
        """
        pulumi.set(__self__, "completion", completion)
        pulumi.set(__self__, "parent_task_id", parent_task_id)
        pulumi.set(__self__, "title", title)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if dependency_direction is not None:
            pulumi.set(__self__, "dependency_direction", dependency_direction)
        if dependent_task_ids is not None:
            pulumi.set(__self__, "dependent_task_ids", dependent_task_ids)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def completion(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="parentTaskId")
    def parent_task_id(self) -> str:
        """
        The parent task id
        """
        return pulumi.get(self, "parent_task_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The subtask title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter(name="dependencyDirection")
    def dependency_direction(self) -> Optional[str]:
        """
        Value must be one of `blocking`, `blocked_by`.
        """
        return pulumi.get(self, "dependency_direction")

    @property
    @pulumi.getter(name="dependentTaskIds")
    def dependent_task_ids(self) -> Optional[Sequence[str]]:
        """
        Dependent task ids. Supports liquid syntax
        """
        return pulumi.get(self, "dependent_task_ids")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def notes(self) -> Optional[str]:
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateAsanaTaskTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "dependencyDirection":
            suggest = "dependency_direction"
        elif key == "dependentTaskIds":
            suggest = "dependent_task_ids"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateAsanaTaskTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateAsanaTaskTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateAsanaTaskTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completion: Mapping[str, str],
                 projects: Sequence['outputs.WorkflowTaskCreateAsanaTaskTaskParamsProject'],
                 title: str,
                 workspace: Mapping[str, str],
                 assign_user_email: Optional[str] = None,
                 custom_fields_mapping: Optional[str] = None,
                 dependency_direction: Optional[str] = None,
                 dependent_task_ids: Optional[Sequence[str]] = None,
                 due_date: Optional[str] = None,
                 notes: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`.
        :param str title: The task title
        :param Mapping[str, str] workspace: Map must contain two fields, `id` and `name`.
        :param str assign_user_email: The assigned user's email
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str dependency_direction: Value must be one of `blocking`, `blocked_by`.
        :param Sequence[str] dependent_task_ids: Dependent task ids. Supports liquid syntax
        :param str due_date: The due date
        """
        pulumi.set(__self__, "completion", completion)
        pulumi.set(__self__, "projects", projects)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "workspace", workspace)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if dependency_direction is not None:
            pulumi.set(__self__, "dependency_direction", dependency_direction)
        if dependent_task_ids is not None:
            pulumi.set(__self__, "dependent_task_ids", dependent_task_ids)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def completion(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter
    def projects(self) -> Sequence['outputs.WorkflowTaskCreateAsanaTaskTaskParamsProject']:
        return pulumi.get(self, "projects")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The task title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def workspace(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "workspace")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter(name="dependencyDirection")
    def dependency_direction(self) -> Optional[str]:
        """
        Value must be one of `blocking`, `blocked_by`.
        """
        return pulumi.get(self, "dependency_direction")

    @property
    @pulumi.getter(name="dependentTaskIds")
    def dependent_task_ids(self) -> Optional[Sequence[str]]:
        """
        Dependent task ids. Supports liquid syntax
        """
        return pulumi.get(self, "dependent_task_ids")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def notes(self) -> Optional[str]:
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateAsanaTaskTaskParamsProject(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateClickupTaskTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "taskPayload":
            suggest = "task_payload"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateClickupTaskTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateClickupTaskTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateClickupTaskTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: str,
                 custom_fields_mapping: Optional[str] = None,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 tags: Optional[str] = None,
                 task_payload: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str title: The task title
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str description: The task description
        :param str due_date: The due date
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param str tags: The task tags
        :param str task_payload: Additional ClickUp task attributes. Will be merged into whatever was specified in this tasks current parameters. Can contain liquid markup and need to be valid JSON
        """
        pulumi.set(__self__, "title", title)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_payload is not None:
            pulumi.set(__self__, "task_payload", task_payload)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The task title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The task description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def tags(self) -> Optional[str]:
        """
        The task tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="taskPayload")
    def task_payload(self) -> Optional[str]:
        """
        Additional ClickUp task attributes. Will be merged into whatever was specified in this tasks current parameters. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "task_payload")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateConfluencePageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markPostMortemAsPublished":
            suggest = "mark_post_mortem_as_published"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateConfluencePageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateConfluencePageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateConfluencePageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 space: Mapping[str, str],
                 title: str,
                 ancestor: Optional[Mapping[str, str]] = None,
                 content: Optional[str] = None,
                 integration: Optional[Mapping[str, str]] = None,
                 mark_post_mortem_as_published: Optional[bool] = None,
                 post_mortem_template_id: Optional[str] = None,
                 task_type: Optional[str] = None,
                 template: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] space: Map must contain two fields, `id` and `name`.
        :param str title: The page title
        :param Mapping[str, str] ancestor: Map must contain two fields, `id` and `name`.
        :param str content: The page content
        :param Mapping[str, str] integration: Map must contain two fields, `id` and `name`. Specify integration id if you have more than one Confluence instance
        :param bool mark_post_mortem_as_published: Value must be one of true or false
        :param str post_mortem_template_id: The Retrospective template to use
        :param Mapping[str, str] template: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "space", space)
        pulumi.set(__self__, "title", title)
        if ancestor is not None:
            pulumi.set(__self__, "ancestor", ancestor)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if integration is not None:
            pulumi.set(__self__, "integration", integration)
        if mark_post_mortem_as_published is not None:
            pulumi.set(__self__, "mark_post_mortem_as_published", mark_post_mortem_as_published)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def space(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "space")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The page title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def ancestor(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "ancestor")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The page content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def integration(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. Specify integration id if you have more than one Confluence instance
        """
        return pulumi.get(self, "integration")

    @property
    @pulumi.getter(name="markPostMortemAsPublished")
    def mark_post_mortem_as_published(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "mark_post_mortem_as_published")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        The Retrospective template to use
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def template(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class WorkflowTaskCreateDatadogNotebookTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markPostMortemAsPublished":
            suggest = "mark_post_mortem_as_published"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateDatadogNotebookTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateDatadogNotebookTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateDatadogNotebookTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: str,
                 title: str,
                 content: Optional[str] = None,
                 mark_post_mortem_as_published: Optional[bool] = None,
                 post_mortem_template_id: Optional[str] = None,
                 task_type: Optional[str] = None,
                 template: Optional[Mapping[str, str]] = None):
        """
        :param str kind: The notebook kind. Value must be one of `postmortem`, `runbook`, `investigation`, `documentation`, `report`.
        :param str title: The notebook title
        :param str content: The notebook content
        :param bool mark_post_mortem_as_published: Value must be one of true or false
        :param str post_mortem_template_id: Retrospective template to use when creating notebook, if desired
        :param Mapping[str, str] template: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "title", title)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if mark_post_mortem_as_published is not None:
            pulumi.set(__self__, "mark_post_mortem_as_published", mark_post_mortem_as_published)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The notebook kind. Value must be one of `postmortem`, `runbook`, `investigation`, `documentation`, `report`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The notebook title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The notebook content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="markPostMortemAsPublished")
    def mark_post_mortem_as_published(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "mark_post_mortem_as_published")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        Retrospective template to use when creating notebook, if desired
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def template(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class WorkflowTaskCreateDropboxPaperPageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markPostMortemAsPublished":
            suggest = "mark_post_mortem_as_published"
        elif key == "parentFolder":
            suggest = "parent_folder"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateDropboxPaperPageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateDropboxPaperPageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateDropboxPaperPageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: str,
                 content: Optional[str] = None,
                 mark_post_mortem_as_published: Optional[bool] = None,
                 namespace: Optional[Mapping[str, str]] = None,
                 parent_folder: Optional[Mapping[str, str]] = None,
                 post_mortem_template_id: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str title: The page task title
        :param str content: The page content
        :param bool mark_post_mortem_as_published: Value must be one of true or false
        :param Mapping[str, str] namespace: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] parent_folder: Map must contain two fields, `id` and `name`.
        :param str post_mortem_template_id: Retrospective template to use when creating page task, if desired
        """
        pulumi.set(__self__, "title", title)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if mark_post_mortem_as_published is not None:
            pulumi.set(__self__, "mark_post_mortem_as_published", mark_post_mortem_as_published)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if parent_folder is not None:
            pulumi.set(__self__, "parent_folder", parent_folder)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The page task title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The page content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="markPostMortemAsPublished")
    def mark_post_mortem_as_published(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "mark_post_mortem_as_published")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="parentFolder")
    def parent_folder(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "parent_folder")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        Retrospective template to use when creating page task, if desired
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateGithubIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateGithubIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateGithubIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateGithubIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository: Mapping[str, str],
                 title: str,
                 body: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] repository: Map must contain two fields, `id` and `name`.
        :param str title: The issue title
        :param str body: The issue body
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "title", title)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def repository(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The issue body
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateGitlabIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dueDate":
            suggest = "due_date"
        elif key == "issueType":
            suggest = "issue_type"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateGitlabIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateGitlabIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateGitlabIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository: Mapping[str, str],
                 title: str,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 issue_type: Optional[str] = None,
                 labels: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] repository: Map must contain two fields, `id` and `name`.
        :param str title: The issue title
        :param str description: The issue description
        :param str due_date: The due date
        :param str issue_type: The issue type. Value must be one of `issue`, `incident`, `test_case`, `task`.
        :param str labels: The issue labels
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if issue_type is not None:
            pulumi.set(__self__, "issue_type", issue_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def repository(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The issue description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> Optional[str]:
        """
        The issue type. Value must be one of `issue`, `incident`, `test_case`, `task`.
        """
        return pulumi.get(self, "issue_type")

    @property
    @pulumi.getter
    def labels(self) -> Optional[str]:
        """
        The issue labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateGoToMeetingTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conferenceCallInfo":
            suggest = "conference_call_info"
        elif key == "passwordRequired":
            suggest = "password_required"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateGoToMeetingTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateGoToMeetingTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateGoToMeetingTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subject: str,
                 conference_call_info: Optional[str] = None,
                 password_required: Optional[bool] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskCreateGoToMeetingTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param str subject: The meeting subject
        :param str conference_call_info: Value must be one of `ptsn`, `free`, `hyrid`, `voip`.
        :param bool password_required: Value must be one of true or false
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "subject", subject)
        if conference_call_info is not None:
            pulumi.set(__self__, "conference_call_info", conference_call_info)
        if password_required is not None:
            pulumi.set(__self__, "password_required", password_required)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The meeting subject
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="conferenceCallInfo")
    def conference_call_info(self) -> Optional[str]:
        """
        Value must be one of `ptsn`, `free`, `hyrid`, `voip`.
        """
        return pulumi.get(self, "conference_call_info")

    @property
    @pulumi.getter(name="passwordRequired")
    def password_required(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "password_required")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateGoToMeetingTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateGoToMeetingTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateGoogleCalendarEventTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysUntilMeeting":
            suggest = "days_until_meeting"
        elif key == "meetingDuration":
            suggest = "meeting_duration"
        elif key == "timeOfMeeting":
            suggest = "time_of_meeting"
        elif key == "canGuestsInviteOthers":
            suggest = "can_guests_invite_others"
        elif key == "canGuestsModifyEvent":
            suggest = "can_guests_modify_event"
        elif key == "canGuestsSeeOtherGuests":
            suggest = "can_guests_see_other_guests"
        elif key == "conferenceSolutionKey":
            suggest = "conference_solution_key"
        elif key == "excludeWeekends":
            suggest = "exclude_weekends"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "sendUpdates":
            suggest = "send_updates"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateGoogleCalendarEventTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateGoogleCalendarEventTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateGoogleCalendarEventTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_until_meeting: int,
                 description: str,
                 meeting_duration: str,
                 summary: str,
                 time_of_meeting: str,
                 attendees: Optional[Sequence[str]] = None,
                 can_guests_invite_others: Optional[bool] = None,
                 can_guests_modify_event: Optional[bool] = None,
                 can_guests_see_other_guests: Optional[bool] = None,
                 conference_solution_key: Optional[str] = None,
                 exclude_weekends: Optional[bool] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskCreateGoogleCalendarEventTaskParamsPostToSlackChannel']] = None,
                 send_updates: Optional[bool] = None,
                 task_type: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        :param int days_until_meeting: The days until meeting
        :param str description: The event description
        :param str meeting_duration: Meeting duration in format like '1 hour', '30 minutes'
        :param str summary: The event summary
        :param str time_of_meeting: Time of meeting in format HH:MM
        :param Sequence[str] attendees: Emails of attendees
        :param bool can_guests_invite_others: Value must be one of true or false
        :param bool can_guests_modify_event: Value must be one of true or false
        :param bool can_guests_see_other_guests: Value must be one of true or false
        :param str conference_solution_key: Sets the video conference type attached to the meeting. Value must be one of `eventHangout`, `eventNamedHangout`, `hangoutsMeet`, `addOn`.
        :param bool exclude_weekends: Value must be one of true or false
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool send_updates: Send an email to the attendees notifying them of the event. Value must be one of true or false
        :param str time_zone: A valid IANA time zone name.
        """
        pulumi.set(__self__, "days_until_meeting", days_until_meeting)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "meeting_duration", meeting_duration)
        pulumi.set(__self__, "summary", summary)
        pulumi.set(__self__, "time_of_meeting", time_of_meeting)
        if attendees is not None:
            pulumi.set(__self__, "attendees", attendees)
        if can_guests_invite_others is not None:
            pulumi.set(__self__, "can_guests_invite_others", can_guests_invite_others)
        if can_guests_modify_event is not None:
            pulumi.set(__self__, "can_guests_modify_event", can_guests_modify_event)
        if can_guests_see_other_guests is not None:
            pulumi.set(__self__, "can_guests_see_other_guests", can_guests_see_other_guests)
        if conference_solution_key is not None:
            pulumi.set(__self__, "conference_solution_key", conference_solution_key)
        if exclude_weekends is not None:
            pulumi.set(__self__, "exclude_weekends", exclude_weekends)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if send_updates is not None:
            pulumi.set(__self__, "send_updates", send_updates)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="daysUntilMeeting")
    def days_until_meeting(self) -> int:
        """
        The days until meeting
        """
        return pulumi.get(self, "days_until_meeting")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The event description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="meetingDuration")
    def meeting_duration(self) -> str:
        """
        Meeting duration in format like '1 hour', '30 minutes'
        """
        return pulumi.get(self, "meeting_duration")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The event summary
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="timeOfMeeting")
    def time_of_meeting(self) -> str:
        """
        Time of meeting in format HH:MM
        """
        return pulumi.get(self, "time_of_meeting")

    @property
    @pulumi.getter
    def attendees(self) -> Optional[Sequence[str]]:
        """
        Emails of attendees
        """
        return pulumi.get(self, "attendees")

    @property
    @pulumi.getter(name="canGuestsInviteOthers")
    def can_guests_invite_others(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "can_guests_invite_others")

    @property
    @pulumi.getter(name="canGuestsModifyEvent")
    def can_guests_modify_event(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "can_guests_modify_event")

    @property
    @pulumi.getter(name="canGuestsSeeOtherGuests")
    def can_guests_see_other_guests(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "can_guests_see_other_guests")

    @property
    @pulumi.getter(name="conferenceSolutionKey")
    def conference_solution_key(self) -> Optional[str]:
        """
        Sets the video conference type attached to the meeting. Value must be one of `eventHangout`, `eventNamedHangout`, `hangoutsMeet`, `addOn`.
        """
        return pulumi.get(self, "conference_solution_key")

    @property
    @pulumi.getter(name="excludeWeekends")
    def exclude_weekends(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "exclude_weekends")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateGoogleCalendarEventTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="sendUpdates")
    def send_updates(self) -> Optional[bool]:
        """
        Send an email to the attendees notifying them of the event. Value must be one of true or false
        """
        return pulumi.get(self, "send_updates")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        A valid IANA time zone name.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class WorkflowTaskCreateGoogleCalendarEventTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateGoogleDocsPageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markPostMortemAsPublished":
            suggest = "mark_post_mortem_as_published"
        elif key == "parentFolder":
            suggest = "parent_folder"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "templateId":
            suggest = "template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateGoogleDocsPageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateGoogleDocsPageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateGoogleDocsPageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: str,
                 content: Optional[str] = None,
                 drive: Optional[Mapping[str, str]] = None,
                 mark_post_mortem_as_published: Optional[bool] = None,
                 parent_folder: Optional[Mapping[str, str]] = None,
                 permissions: Optional[str] = None,
                 post_mortem_template_id: Optional[str] = None,
                 task_type: Optional[str] = None,
                 template_id: Optional[str] = None):
        """
        :param str title: The page title
        :param str content: The page content
        :param Mapping[str, str] drive: Map must contain two fields, `id` and `name`.
        :param bool mark_post_mortem_as_published: Value must be one of true or false
        :param Mapping[str, str] parent_folder: Map must contain two fields, `id` and `name`.
        :param str permissions: Page permissions JSON
        :param str post_mortem_template_id: Retrospective template to use when creating page, if desired
        :param str template_id: The Google Doc file ID to use as a template
        """
        pulumi.set(__self__, "title", title)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if drive is not None:
            pulumi.set(__self__, "drive", drive)
        if mark_post_mortem_as_published is not None:
            pulumi.set(__self__, "mark_post_mortem_as_published", mark_post_mortem_as_published)
        if parent_folder is not None:
            pulumi.set(__self__, "parent_folder", parent_folder)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The page title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The page content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def drive(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "drive")

    @property
    @pulumi.getter(name="markPostMortemAsPublished")
    def mark_post_mortem_as_published(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "mark_post_mortem_as_published")

    @property
    @pulumi.getter(name="parentFolder")
    def parent_folder(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "parent_folder")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[str]:
        """
        Page permissions JSON
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        Retrospective template to use when creating page, if desired
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[str]:
        """
        The Google Doc file ID to use as a template
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class WorkflowTaskCreateGoogleDocsPermissionsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileId":
            suggest = "file_id"
        elif key == "emailMessage":
            suggest = "email_message"
        elif key == "sendNotificationEmail":
            suggest = "send_notification_email"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateGoogleDocsPermissionsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateGoogleDocsPermissionsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateGoogleDocsPermissionsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_id: str,
                 permissions: str,
                 email_message: Optional[str] = None,
                 send_notification_email: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param str file_id: The Google Doc file ID
        :param str permissions: Page permissions JSON
        :param str email_message: Email message notification
        :param bool send_notification_email: Value must be one of true or false
        """
        pulumi.set(__self__, "file_id", file_id)
        pulumi.set(__self__, "permissions", permissions)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if send_notification_email is not None:
            pulumi.set(__self__, "send_notification_email", send_notification_email)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> str:
        """
        The Google Doc file ID
        """
        return pulumi.get(self, "file_id")

    @property
    @pulumi.getter
    def permissions(self) -> str:
        """
        Page permissions JSON
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[str]:
        """
        Email message notification
        """
        return pulumi.get(self, "email_message")

    @property
    @pulumi.getter(name="sendNotificationEmail")
    def send_notification_email(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "send_notification_email")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateGoogleMeetingTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conferenceSolutionKey":
            suggest = "conference_solution_key"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "recordMeeting":
            suggest = "record_meeting"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateGoogleMeetingTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateGoogleMeetingTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateGoogleMeetingTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 summary: str,
                 conference_solution_key: Optional[str] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskCreateGoogleMeetingTaskParamsPostToSlackChannel']] = None,
                 record_meeting: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param str description: The meeting description
        :param str summary: The meeting summary
        :param str conference_solution_key: Sets the video conference type attached to the meeting. Value must be one of `eventHangout`, `eventNamedHangout`, `hangoutsMeet`, `addOn`.
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool record_meeting: We will invite Rootly Bot to your call and make the transcript available to you. Value must be one of true or false
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "summary", summary)
        if conference_solution_key is not None:
            pulumi.set(__self__, "conference_solution_key", conference_solution_key)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if record_meeting is not None:
            pulumi.set(__self__, "record_meeting", record_meeting)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The meeting description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The meeting summary
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="conferenceSolutionKey")
    def conference_solution_key(self) -> Optional[str]:
        """
        Sets the video conference type attached to the meeting. Value must be one of `eventHangout`, `eventNamedHangout`, `hangoutsMeet`, `addOn`.
        """
        return pulumi.get(self, "conference_solution_key")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateGoogleMeetingTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="recordMeeting")
    def record_meeting(self) -> Optional[bool]:
        """
        We will invite Rootly Bot to your call and make the transcript available to you. Value must be one of true or false
        """
        return pulumi.get(self, "record_meeting")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateGoogleMeetingTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateIncidentPostmortemTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentId":
            suggest = "incident_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateIncidentPostmortemTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateIncidentPostmortemTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateIncidentPostmortemTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_id: str,
                 title: str,
                 status: Optional[str] = None,
                 task_type: Optional[str] = None,
                 template: Optional[Mapping[str, str]] = None):
        """
        :param str incident_id: UUID of the incident that needs a retrospective
        :param str title: The retrospective title
        :param Mapping[str, str] template: Map must contain two fields, `id` and `name`. Retrospective template to use
        """
        pulumi.set(__self__, "incident_id", incident_id)
        pulumi.set(__self__, "title", title)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter(name="incidentId")
    def incident_id(self) -> str:
        """
        UUID of the incident that needs a retrospective
        """
        return pulumi.get(self, "incident_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The retrospective title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def template(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. Retrospective template to use
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class WorkflowTaskCreateIncidentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "environmentIds":
            suggest = "environment_ids"
        elif key == "functionalityIds":
            suggest = "functionality_ids"
        elif key == "groupIds":
            suggest = "group_ids"
        elif key == "incidentTypeIds":
            suggest = "incident_type_ids"
        elif key == "serviceIds":
            suggest = "service_ids"
        elif key == "severityId":
            suggest = "severity_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateIncidentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateIncidentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateIncidentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: str,
                 custom_fields_mapping: Optional[str] = None,
                 environment_ids: Optional[Sequence[str]] = None,
                 functionality_ids: Optional[Sequence[str]] = None,
                 group_ids: Optional[Sequence[str]] = None,
                 incident_type_ids: Optional[Sequence[str]] = None,
                 private: Optional[bool] = None,
                 service_ids: Optional[Sequence[str]] = None,
                 severity_id: Optional[str] = None,
                 summary: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str title: The incident title
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param bool private: Value must be one of true or false
        :param str summary: The incident summary
        """
        pulumi.set(__self__, "title", title)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if environment_ids is not None:
            pulumi.set(__self__, "environment_ids", environment_ids)
        if functionality_ids is not None:
            pulumi.set(__self__, "functionality_ids", functionality_ids)
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if incident_type_ids is not None:
            pulumi.set(__self__, "incident_type_ids", incident_type_ids)
        if private is not None:
            pulumi.set(__self__, "private", private)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)
        if severity_id is not None:
            pulumi.set(__self__, "severity_id", severity_id)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The incident title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter(name="environmentIds")
    def environment_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "environment_ids")

    @property
    @pulumi.getter(name="functionalityIds")
    def functionality_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "functionality_ids")

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="incidentTypeIds")
    def incident_type_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "incident_type_ids")

    @property
    @pulumi.getter
    def private(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_ids")

    @property
    @pulumi.getter(name="severityId")
    def severity_id(self) -> Optional[str]:
        return pulumi.get(self, "severity_id")

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        The incident summary
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateJiraIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issueType":
            suggest = "issue_type"
        elif key == "projectKey":
            suggest = "project_key"
        elif key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "reporterUserEmail":
            suggest = "reporter_user_email"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "updatePayload":
            suggest = "update_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateJiraIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateJiraIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateJiraIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issue_type: Mapping[str, str],
                 project_key: str,
                 title: str,
                 assign_user_email: Optional[str] = None,
                 custom_fields_mapping: Optional[str] = None,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 integration: Optional[Mapping[str, str]] = None,
                 labels: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 reporter_user_email: Optional[str] = None,
                 status: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 update_payload: Optional[str] = None):
        """
        :param Mapping[str, str] issue_type: Map must contain two fields, `id` and `name`. The issue type id and display name
        :param str project_key: The project key
        :param str title: The issue title
        :param str assign_user_email: The assigned user's email
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str description: The issue description
        :param str due_date: The due date
        :param Mapping[str, str] integration: Map must contain two fields, `id` and `name`. Specify integration id if you have more than one Jira instance
        :param str labels: The issue labels
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param str reporter_user_email: The reporter user's email
        :param Mapping[str, str] status: Map must contain two fields, `id` and `name`. The status id and display name
        :param str update_payload: Update payload. Can contain liquid markup and need to be valid JSON
        """
        pulumi.set(__self__, "issue_type", issue_type)
        pulumi.set(__self__, "project_key", project_key)
        pulumi.set(__self__, "title", title)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if integration is not None:
            pulumi.set(__self__, "integration", integration)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if reporter_user_email is not None:
            pulumi.set(__self__, "reporter_user_email", reporter_user_email)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if update_payload is not None:
            pulumi.set(__self__, "update_payload", update_payload)

    @property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The issue type id and display name
        """
        return pulumi.get(self, "issue_type")

    @property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> str:
        """
        The project key
        """
        return pulumi.get(self, "project_key")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The issue description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def integration(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. Specify integration id if you have more than one Jira instance
        """
        return pulumi.get(self, "integration")

    @property
    @pulumi.getter
    def labels(self) -> Optional[str]:
        """
        The issue labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="reporterUserEmail")
    def reporter_user_email(self) -> Optional[str]:
        """
        The reporter user's email
        """
        return pulumi.get(self, "reporter_user_email")

    @property
    @pulumi.getter
    def status(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The status id and display name
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="updatePayload")
    def update_payload(self) -> Optional[str]:
        """
        Update payload. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "update_payload")


@pulumi.output_type
class WorkflowTaskCreateJiraSubtaskTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentIssueId":
            suggest = "parent_issue_id"
        elif key == "projectKey":
            suggest = "project_key"
        elif key == "subtaskIssueType":
            suggest = "subtask_issue_type"
        elif key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "reporterUserEmail":
            suggest = "reporter_user_email"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "updatePayload":
            suggest = "update_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateJiraSubtaskTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateJiraSubtaskTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateJiraSubtaskTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parent_issue_id: str,
                 project_key: str,
                 subtask_issue_type: Mapping[str, str],
                 title: str,
                 assign_user_email: Optional[str] = None,
                 custom_fields_mapping: Optional[str] = None,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 integration: Optional[Mapping[str, str]] = None,
                 labels: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 reporter_user_email: Optional[str] = None,
                 status: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 update_payload: Optional[str] = None):
        """
        :param str parent_issue_id: The parent issue
        :param str project_key: The project key
        :param Mapping[str, str] subtask_issue_type: Map must contain two fields, `id` and `name`. The issue type id and display name
        :param str title: The issue title
        :param str assign_user_email: The assigned user's email
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str description: The issue description
        :param str due_date: The due date
        :param Mapping[str, str] integration: Map must contain two fields, `id` and `name`. Specify integration id if you have more than one Jira instance
        :param str labels: The issue labels
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param str reporter_user_email: The reporter user's email
        :param Mapping[str, str] status: Map must contain two fields, `id` and `name`. The status id and display name
        :param str update_payload: Update payload. Can contain liquid markup and need to be valid JSON
        """
        pulumi.set(__self__, "parent_issue_id", parent_issue_id)
        pulumi.set(__self__, "project_key", project_key)
        pulumi.set(__self__, "subtask_issue_type", subtask_issue_type)
        pulumi.set(__self__, "title", title)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if integration is not None:
            pulumi.set(__self__, "integration", integration)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if reporter_user_email is not None:
            pulumi.set(__self__, "reporter_user_email", reporter_user_email)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if update_payload is not None:
            pulumi.set(__self__, "update_payload", update_payload)

    @property
    @pulumi.getter(name="parentIssueId")
    def parent_issue_id(self) -> str:
        """
        The parent issue
        """
        return pulumi.get(self, "parent_issue_id")

    @property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> str:
        """
        The project key
        """
        return pulumi.get(self, "project_key")

    @property
    @pulumi.getter(name="subtaskIssueType")
    def subtask_issue_type(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The issue type id and display name
        """
        return pulumi.get(self, "subtask_issue_type")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The issue description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def integration(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. Specify integration id if you have more than one Jira instance
        """
        return pulumi.get(self, "integration")

    @property
    @pulumi.getter
    def labels(self) -> Optional[str]:
        """
        The issue labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="reporterUserEmail")
    def reporter_user_email(self) -> Optional[str]:
        """
        The reporter user's email
        """
        return pulumi.get(self, "reporter_user_email")

    @property
    @pulumi.getter
    def status(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The status id and display name
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="updatePayload")
    def update_payload(self) -> Optional[str]:
        """
        Update payload. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "update_payload")


@pulumi.output_type
class WorkflowTaskCreateLinearIssueCommentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issueId":
            suggest = "issue_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateLinearIssueCommentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateLinearIssueCommentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateLinearIssueCommentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: str,
                 issue_id: str,
                 task_type: Optional[str] = None):
        """
        :param str body: The issue description
        :param str issue_id: The issue id
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "issue_id", issue_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The issue description
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="issueId")
    def issue_id(self) -> str:
        """
        The issue id
        """
        return pulumi.get(self, "issue_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateLinearIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateLinearIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateLinearIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateLinearIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: Mapping[str, str],
                 team: Mapping[str, str],
                 title: str,
                 assign_user_email: Optional[str] = None,
                 description: Optional[str] = None,
                 labels: Optional[Sequence['outputs.WorkflowTaskCreateLinearIssueTaskParamsLabel']] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 project: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] state: Map must contain two fields, `id` and `name`. The state id and display name
        :param Mapping[str, str] team: Map must contain two fields, `id` and `name`. The team id and display name
        :param str title: The issue title
        :param str assign_user_email: The assigned user's email
        :param str description: The issue description
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param Mapping[str, str] project: Map must contain two fields, `id` and `name`. The project id and display name
        """
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "team", team)
        pulumi.set(__self__, "title", title)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def state(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The state id and display name
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def team(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The team id and display name
        """
        return pulumi.get(self, "team")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The issue description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateLinearIssueTaskParamsLabel']]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def project(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The project id and display name
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateLinearIssueTaskParamsLabel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateLinearSubtaskIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentIssueId":
            suggest = "parent_issue_id"
        elif key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateLinearSubtaskIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateLinearSubtaskIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateLinearSubtaskIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parent_issue_id: str,
                 state: Mapping[str, str],
                 title: str,
                 assign_user_email: Optional[str] = None,
                 description: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None):
        """
        :param str parent_issue_id: The parent issue
        :param Mapping[str, str] state: Map must contain two fields, `id` and `name`. The state id and display name
        :param str title: The issue title
        :param str assign_user_email: The assigned user's email
        :param str description: The issue description
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        """
        pulumi.set(__self__, "parent_issue_id", parent_issue_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "title", title)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="parentIssueId")
    def parent_issue_id(self) -> str:
        """
        The parent issue
        """
        return pulumi.get(self, "parent_issue_id")

    @property
    @pulumi.getter
    def state(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The state id and display name
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The issue description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateMicrosoftTeamsMeetingTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "recordMeeting":
            suggest = "record_meeting"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateMicrosoftTeamsMeetingTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateMicrosoftTeamsMeetingTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateMicrosoftTeamsMeetingTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 subject: str,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskCreateMicrosoftTeamsMeetingTaskParamsPostToSlackChannel']] = None,
                 record_meeting: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param str name: The meeting name
        :param str subject: The meeting subject
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool record_meeting: We will invite Rootly Bot to your call and make the transcript available to you. Value must be one of true or false
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if record_meeting is not None:
            pulumi.set(__self__, "record_meeting", record_meeting)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The meeting name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The meeting subject
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateMicrosoftTeamsMeetingTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="recordMeeting")
    def record_meeting(self) -> Optional[bool]:
        """
        We will invite Rootly Bot to your call and make the transcript available to you. Value must be one of true or false
        """
        return pulumi.get(self, "record_meeting")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateMicrosoftTeamsMeetingTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateNotionPageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentPage":
            suggest = "parent_page"
        elif key == "markPostMortemAsPublished":
            suggest = "mark_post_mortem_as_published"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "showActionItemsAsTable":
            suggest = "show_action_items_as_table"
        elif key == "showTimelineAsTable":
            suggest = "show_timeline_as_table"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateNotionPageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateNotionPageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateNotionPageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parent_page: Mapping[str, str],
                 title: str,
                 mark_post_mortem_as_published: Optional[bool] = None,
                 post_mortem_template_id: Optional[str] = None,
                 show_action_items_as_table: Optional[bool] = None,
                 show_timeline_as_table: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] parent_page: Map must contain two fields, `id` and `name`. The parent page id and display name
        :param str title: The Notion page title
        :param bool mark_post_mortem_as_published: Value must be one of true or false
        :param str post_mortem_template_id: Retrospective template to use when creating page task, if desired
        :param bool show_action_items_as_table: Value must be one of true or false
        :param bool show_timeline_as_table: Value must be one of true or false
        """
        pulumi.set(__self__, "parent_page", parent_page)
        pulumi.set(__self__, "title", title)
        if mark_post_mortem_as_published is not None:
            pulumi.set(__self__, "mark_post_mortem_as_published", mark_post_mortem_as_published)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if show_action_items_as_table is not None:
            pulumi.set(__self__, "show_action_items_as_table", show_action_items_as_table)
        if show_timeline_as_table is not None:
            pulumi.set(__self__, "show_timeline_as_table", show_timeline_as_table)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="parentPage")
    def parent_page(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The parent page id and display name
        """
        return pulumi.get(self, "parent_page")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The Notion page title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="markPostMortemAsPublished")
    def mark_post_mortem_as_published(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "mark_post_mortem_as_published")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        Retrospective template to use when creating page task, if desired
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="showActionItemsAsTable")
    def show_action_items_as_table(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "show_action_items_as_table")

    @property
    @pulumi.getter(name="showTimelineAsTable")
    def show_timeline_as_table(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "show_timeline_as_table")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateOpsgenieAlertTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateOpsgenieAlertTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateOpsgenieAlertTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateOpsgenieAlertTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 description: Optional[str] = None,
                 escalations: Optional[Sequence['outputs.WorkflowTaskCreateOpsgenieAlertTaskParamsEscalation']] = None,
                 priority: Optional[str] = None,
                 schedules: Optional[Sequence['outputs.WorkflowTaskCreateOpsgenieAlertTaskParamsSchedule']] = None,
                 task_type: Optional[str] = None,
                 teams: Optional[Sequence['outputs.WorkflowTaskCreateOpsgenieAlertTaskParamsTeam']] = None,
                 users: Optional[Sequence['outputs.WorkflowTaskCreateOpsgenieAlertTaskParamsUser']] = None):
        """
        :param str message: Message of the alert
        :param str description: Description field of the alert that is generally used to provide a detailed information about the alert
        :param str priority: Value must be one of `P1`, `P2`, `P3`, `P4`, `P5`, `auto`.
        """
        pulumi.set(__self__, "message", message)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if escalations is not None:
            pulumi.set(__self__, "escalations", escalations)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message of the alert
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description field of the alert that is generally used to provide a detailed information about the alert
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def escalations(self) -> Optional[Sequence['outputs.WorkflowTaskCreateOpsgenieAlertTaskParamsEscalation']]:
        return pulumi.get(self, "escalations")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        Value must be one of `P1`, `P2`, `P3`, `P4`, `P5`, `auto`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def schedules(self) -> Optional[Sequence['outputs.WorkflowTaskCreateOpsgenieAlertTaskParamsSchedule']]:
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence['outputs.WorkflowTaskCreateOpsgenieAlertTaskParamsTeam']]:
        return pulumi.get(self, "teams")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.WorkflowTaskCreateOpsgenieAlertTaskParamsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class WorkflowTaskCreateOpsgenieAlertTaskParamsEscalation(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateOpsgenieAlertTaskParamsSchedule(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateOpsgenieAlertTaskParamsTeam(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateOpsgenieAlertTaskParamsUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateOutlookEventTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysUntilMeeting":
            suggest = "days_until_meeting"
        elif key == "meetingDuration":
            suggest = "meeting_duration"
        elif key == "timeOfMeeting":
            suggest = "time_of_meeting"
        elif key == "excludeWeekends":
            suggest = "exclude_weekends"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateOutlookEventTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateOutlookEventTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateOutlookEventTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calendar: Mapping[str, str],
                 days_until_meeting: int,
                 description: str,
                 meeting_duration: str,
                 summary: str,
                 time_of_meeting: str,
                 attendees: Optional[Sequence[str]] = None,
                 exclude_weekends: Optional[bool] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskCreateOutlookEventTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        :param Mapping[str, str] calendar: Map must contain two fields, `id` and `name`.
        :param int days_until_meeting: The days until meeting
        :param str description: The event description
        :param str meeting_duration: Meeting duration in format like '1 hour', '30 minutes'
        :param str summary: The event summary
        :param str time_of_meeting: Time of meeting in format HH:MM
        :param Sequence[str] attendees: Emails of attendees
        :param bool exclude_weekends: Value must be one of true or false
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param str time_zone: A valid IANA time zone name.
        """
        pulumi.set(__self__, "calendar", calendar)
        pulumi.set(__self__, "days_until_meeting", days_until_meeting)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "meeting_duration", meeting_duration)
        pulumi.set(__self__, "summary", summary)
        pulumi.set(__self__, "time_of_meeting", time_of_meeting)
        if attendees is not None:
            pulumi.set(__self__, "attendees", attendees)
        if exclude_weekends is not None:
            pulumi.set(__self__, "exclude_weekends", exclude_weekends)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def calendar(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "calendar")

    @property
    @pulumi.getter(name="daysUntilMeeting")
    def days_until_meeting(self) -> int:
        """
        The days until meeting
        """
        return pulumi.get(self, "days_until_meeting")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The event description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="meetingDuration")
    def meeting_duration(self) -> str:
        """
        Meeting duration in format like '1 hour', '30 minutes'
        """
        return pulumi.get(self, "meeting_duration")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The event summary
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="timeOfMeeting")
    def time_of_meeting(self) -> str:
        """
        Time of meeting in format HH:MM
        """
        return pulumi.get(self, "time_of_meeting")

    @property
    @pulumi.getter
    def attendees(self) -> Optional[Sequence[str]]:
        """
        Emails of attendees
        """
        return pulumi.get(self, "attendees")

    @property
    @pulumi.getter(name="excludeWeekends")
    def exclude_weekends(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "exclude_weekends")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateOutlookEventTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        A valid IANA time zone name.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class WorkflowTaskCreateOutlookEventTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreatePagerdutyStatusUpdateTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagerdutyIncidentId":
            suggest = "pagerduty_incident_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreatePagerdutyStatusUpdateTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreatePagerdutyStatusUpdateTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreatePagerdutyStatusUpdateTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 pagerduty_incident_id: str,
                 task_type: Optional[str] = None):
        """
        :param str message: A message outlining the incident's resolution in PagerDuty
        :param str pagerduty_incident_id: PagerDuty incident id
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "pagerduty_incident_id", pagerduty_incident_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A message outlining the incident's resolution in PagerDuty
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="pagerdutyIncidentId")
    def pagerduty_incident_id(self) -> str:
        """
        PagerDuty incident id
        """
        return pulumi.get(self, "pagerduty_incident_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreatePagertreeAlertTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreatePagertreeAlertTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreatePagertreeAlertTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreatePagertreeAlertTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 incident: Optional[bool] = None,
                 severity: Optional[str] = None,
                 task_type: Optional[str] = None,
                 teams: Optional[Sequence['outputs.WorkflowTaskCreatePagertreeAlertTaskParamsTeam']] = None,
                 title: Optional[str] = None,
                 urgency: Optional[str] = None,
                 users: Optional[Sequence['outputs.WorkflowTaskCreatePagertreeAlertTaskParamsUser']] = None):
        """
        :param str description: Description of alert as text
        :param bool incident: Setting to true makes an alert a Pagertree incident. Value must be one of true or false
        :param str severity: Value must be one of `auto`, `SEV-1`, `SEV-2`, `SEV-3`, `SEV-4`.
        :param str title: Title of alert as text
        :param str urgency: Value must be one of `auto`, `critical`, `high`, `medium`, `low`.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if incident is not None:
            pulumi.set(__self__, "incident", incident)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of alert as text
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def incident(self) -> Optional[bool]:
        """
        Setting to true makes an alert a Pagertree incident. Value must be one of true or false
        """
        return pulumi.get(self, "incident")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Value must be one of `auto`, `SEV-1`, `SEV-2`, `SEV-3`, `SEV-4`.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence['outputs.WorkflowTaskCreatePagertreeAlertTaskParamsTeam']]:
        return pulumi.get(self, "teams")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of alert as text
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        Value must be one of `auto`, `critical`, `high`, `medium`, `low`.
        """
        return pulumi.get(self, "urgency")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.WorkflowTaskCreatePagertreeAlertTaskParamsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class WorkflowTaskCreatePagertreeAlertTaskParamsTeam(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreatePagertreeAlertTaskParamsUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateQuipPageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markPostMortemAsPublished":
            suggest = "mark_post_mortem_as_published"
        elif key == "parentFolderId":
            suggest = "parent_folder_id"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "templateId":
            suggest = "template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateQuipPageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateQuipPageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateQuipPageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: str,
                 content: Optional[str] = None,
                 mark_post_mortem_as_published: Optional[bool] = None,
                 parent_folder_id: Optional[str] = None,
                 post_mortem_template_id: Optional[str] = None,
                 task_type: Optional[str] = None,
                 template_id: Optional[str] = None):
        """
        :param str title: The page title
        :param str content: The page content
        :param bool mark_post_mortem_as_published: Value must be one of true or false
        :param str parent_folder_id: The parent folder id
        :param str post_mortem_template_id: Retrospective template to use when creating page, if desired
        :param str template_id: The Quip file ID to use as a template
        """
        pulumi.set(__self__, "title", title)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if mark_post_mortem_as_published is not None:
            pulumi.set(__self__, "mark_post_mortem_as_published", mark_post_mortem_as_published)
        if parent_folder_id is not None:
            pulumi.set(__self__, "parent_folder_id", parent_folder_id)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The page title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The page content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="markPostMortemAsPublished")
    def mark_post_mortem_as_published(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "mark_post_mortem_as_published")

    @property
    @pulumi.getter(name="parentFolderId")
    def parent_folder_id(self) -> Optional[str]:
        """
        The parent folder id
        """
        return pulumi.get(self, "parent_folder_id")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        Retrospective template to use when creating page, if desired
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[str]:
        """
        The Quip file ID to use as a template
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class WorkflowTaskCreateServiceNowIncidentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateServiceNowIncidentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateServiceNowIncidentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateServiceNowIncidentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: str,
                 completion: Optional[Mapping[str, str]] = None,
                 custom_fields_mapping: Optional[str] = None,
                 description: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None):
        """
        :param str title: The incident title
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`. The completion id and display name
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str description: The incident description
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        """
        pulumi.set(__self__, "title", title)
        if completion is not None:
            pulumi.set(__self__, "completion", completion)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The incident title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def completion(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The completion id and display name
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The incident description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateSharepointPageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markPostMortemAsPublished":
            suggest = "mark_post_mortem_as_published"
        elif key == "parentFolder":
            suggest = "parent_folder"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "templateId":
            suggest = "template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateSharepointPageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateSharepointPageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateSharepointPageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drive: Mapping[str, str],
                 site: Mapping[str, str],
                 title: str,
                 content: Optional[str] = None,
                 mark_post_mortem_as_published: Optional[bool] = None,
                 parent_folder: Optional[Mapping[str, str]] = None,
                 post_mortem_template_id: Optional[str] = None,
                 task_type: Optional[str] = None,
                 template_id: Optional[str] = None):
        """
        :param Mapping[str, str] drive: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] site: Map must contain two fields, `id` and `name`.
        :param str title: The page title
        :param str content: The page content
        :param bool mark_post_mortem_as_published: Value must be one of true or false
        :param Mapping[str, str] parent_folder: Map must contain two fields, `id` and `name`.
        :param str post_mortem_template_id: Retrospective template to use when creating page, if desired
        :param str template_id: The SharePoint file ID to use as a template
        """
        pulumi.set(__self__, "drive", drive)
        pulumi.set(__self__, "site", site)
        pulumi.set(__self__, "title", title)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if mark_post_mortem_as_published is not None:
            pulumi.set(__self__, "mark_post_mortem_as_published", mark_post_mortem_as_published)
        if parent_folder is not None:
            pulumi.set(__self__, "parent_folder", parent_folder)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @property
    @pulumi.getter
    def drive(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "drive")

    @property
    @pulumi.getter
    def site(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "site")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The page title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The page content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="markPostMortemAsPublished")
    def mark_post_mortem_as_published(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "mark_post_mortem_as_published")

    @property
    @pulumi.getter(name="parentFolder")
    def parent_folder(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "parent_folder")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        Retrospective template to use when creating page, if desired
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[str]:
        """
        The SharePoint file ID to use as a template
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class WorkflowTaskCreateShortcutStoryTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dueDate":
            suggest = "due_date"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateShortcutStoryTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateShortcutStoryTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateShortcutStoryTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archivation: Mapping[str, str],
                 kind: str,
                 project: Mapping[str, str],
                 title: str,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 labels: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] archivation: Map must contain two fields, `id` and `name`. The archivation id and display name
        :param str kind: Value must be one of `bug`, `chore`, `feature`.
        :param Mapping[str, str] project: Map must contain two fields, `id` and `name`. The project id and display name
        :param str title: The incident title
        :param str description: The incident description
        :param str due_date: The due date
        :param str labels: The story labels
        """
        pulumi.set(__self__, "archivation", archivation)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def archivation(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The archivation id and display name
        """
        return pulumi.get(self, "archivation")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Value must be one of `bug`, `chore`, `feature`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def project(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The project id and display name
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The incident title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The incident description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def labels(self) -> Optional[str]:
        """
        The story labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateShortcutTaskTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentStoryId":
            suggest = "parent_story_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateShortcutTaskTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateShortcutTaskTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateShortcutTaskTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completion: Mapping[str, str],
                 description: str,
                 parent_story_id: str,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`. The completion id and display name
        :param str description: The task description
        :param str parent_story_id: The parent story
        """
        pulumi.set(__self__, "completion", completion)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "parent_story_id", parent_story_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def completion(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The completion id and display name
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The task description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="parentStoryId")
    def parent_story_id(self) -> str:
        """
        The parent story
        """
        return pulumi.get(self, "parent_story_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateSlackChannelTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateSlackChannelTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateSlackChannelTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateSlackChannelTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: str,
                 workspace: Mapping[str, str],
                 private: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str title: Slack channel title
        :param Mapping[str, str] workspace: Map must contain two fields, `id` and `name`.
        :param str private: Value must be one of `auto`, `true`, `false`.
        """
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "workspace", workspace)
        if private is not None:
            pulumi.set(__self__, "private", private)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        Slack channel title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def workspace(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "workspace")

    @property
    @pulumi.getter
    def private(self) -> Optional[str]:
        """
        Value must be one of `auto`, `true`, `false`.
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateTrelloCardTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dueDate":
            suggest = "due_date"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateTrelloCardTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateTrelloCardTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateTrelloCardTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 board: Mapping[str, str],
                 list: Mapping[str, str],
                 title: str,
                 archivation: Optional[Mapping[str, str]] = None,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 labels: Optional[Sequence['outputs.WorkflowTaskCreateTrelloCardTaskParamsLabel']] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] board: Map must contain two fields, `id` and `name`. The board id and display name
        :param Mapping[str, str] list: Map must contain two fields, `id` and `name`. The list id and display name
        :param str title: The card title
        :param Mapping[str, str] archivation: Map must contain two fields, `id` and `name`. The archivation id and display name
        :param str description: The card description
        :param str due_date: The due date
        """
        pulumi.set(__self__, "board", board)
        pulumi.set(__self__, "list", list)
        pulumi.set(__self__, "title", title)
        if archivation is not None:
            pulumi.set(__self__, "archivation", archivation)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def board(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The board id and display name
        """
        return pulumi.get(self, "board")

    @property
    @pulumi.getter
    def list(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The list id and display name
        """
        return pulumi.get(self, "list")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The card title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def archivation(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The archivation id and display name
        """
        return pulumi.get(self, "archivation")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The card description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateTrelloCardTaskParamsLabel']]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateTrelloCardTaskParamsLabel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateWebexMeetingTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "recordMeeting":
            suggest = "record_meeting"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateWebexMeetingTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateWebexMeetingTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateWebexMeetingTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic: str,
                 password: Optional[str] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskCreateWebexMeetingTaskParamsPostToSlackChannel']] = None,
                 record_meeting: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param str topic: The meeting topic
        :param str password: The meeting password
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool record_meeting: We will invite Rootly Bot to your call and make the transcript available to you. Value must be one of true or false
        """
        pulumi.set(__self__, "topic", topic)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if record_meeting is not None:
            pulumi.set(__self__, "record_meeting", record_meeting)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def topic(self) -> str:
        """
        The meeting topic
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The meeting password
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateWebexMeetingTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="recordMeeting")
    def record_meeting(self) -> Optional[bool]:
        """
        We will invite Rootly Bot to your call and make the transcript available to you. Value must be one of true or false
        """
        return pulumi.get(self, "record_meeting")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateWebexMeetingTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskCreateZendeskJiraLinkTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jiraIssueId":
            suggest = "jira_issue_id"
        elif key == "jiraIssueKey":
            suggest = "jira_issue_key"
        elif key == "zendeskTicketId":
            suggest = "zendesk_ticket_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateZendeskJiraLinkTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateZendeskJiraLinkTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateZendeskJiraLinkTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jira_issue_id: str,
                 jira_issue_key: str,
                 zendesk_ticket_id: str,
                 task_type: Optional[str] = None):
        """
        :param str jira_issue_id: Jira Issue Id.
        :param str jira_issue_key: Jira Issue Key.
        :param str zendesk_ticket_id: Zendesk Ticket Id.
        """
        pulumi.set(__self__, "jira_issue_id", jira_issue_id)
        pulumi.set(__self__, "jira_issue_key", jira_issue_key)
        pulumi.set(__self__, "zendesk_ticket_id", zendesk_ticket_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="jiraIssueId")
    def jira_issue_id(self) -> str:
        """
        Jira Issue Id.
        """
        return pulumi.get(self, "jira_issue_id")

    @property
    @pulumi.getter(name="jiraIssueKey")
    def jira_issue_key(self) -> str:
        """
        Jira Issue Key.
        """
        return pulumi.get(self, "jira_issue_key")

    @property
    @pulumi.getter(name="zendeskTicketId")
    def zendesk_ticket_id(self) -> str:
        """
        Zendesk Ticket Id.
        """
        return pulumi.get(self, "zendesk_ticket_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateZendeskTicketTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "ticketPayload":
            suggest = "ticket_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateZendeskTicketTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateZendeskTicketTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateZendeskTicketTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: str,
                 subject: str,
                 comment: Optional[str] = None,
                 completion: Optional[Mapping[str, str]] = None,
                 custom_fields_mapping: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 tags: Optional[str] = None,
                 task_type: Optional[str] = None,
                 ticket_payload: Optional[str] = None):
        """
        :param str kind: Value must be one of `problem`, `incident`, `question`, `task`.
        :param str subject: The ticket subject
        :param str comment: The ticket comment
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`. The completion id and display name
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param str tags: The ticket tags
        :param str ticket_payload: Additional Zendesk ticket attributes. Will be merged into whatever was specified in this tasks current parameters. Can contain liquid markup and need to be valid JSON
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "subject", subject)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if completion is not None:
            pulumi.set(__self__, "completion", completion)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if ticket_payload is not None:
            pulumi.set(__self__, "ticket_payload", ticket_payload)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Value must be one of `problem`, `incident`, `question`, `task`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The ticket subject
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        The ticket comment
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def completion(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The completion id and display name
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def tags(self) -> Optional[str]:
        """
        The ticket tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="ticketPayload")
    def ticket_payload(self) -> Optional[str]:
        """
        Additional Zendesk ticket attributes. Will be merged into whatever was specified in this tasks current parameters. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "ticket_payload")


@pulumi.output_type
class WorkflowTaskCreateZoomMeetingTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternativeHosts":
            suggest = "alternative_hosts"
        elif key == "autoRecording":
            suggest = "auto_recording"
        elif key == "createAsEmail":
            suggest = "create_as_email"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "recordMeeting":
            suggest = "record_meeting"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskCreateZoomMeetingTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskCreateZoomMeetingTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskCreateZoomMeetingTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic: str,
                 alternative_hosts: Optional[Sequence[str]] = None,
                 auto_recording: Optional[str] = None,
                 create_as_email: Optional[str] = None,
                 password: Optional[str] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskCreateZoomMeetingTaskParamsPostToSlackChannel']] = None,
                 record_meeting: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param str topic: The meeting topic
        :param str auto_recording: Value must be one of `none`, `local`, `cloud`.
        :param str create_as_email: The email to use if creating as email
        :param str password: The meeting password
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool record_meeting: We will invite Rootly Bot to your call and make the transcript available to you. Value must be one of true or false
        """
        pulumi.set(__self__, "topic", topic)
        if alternative_hosts is not None:
            pulumi.set(__self__, "alternative_hosts", alternative_hosts)
        if auto_recording is not None:
            pulumi.set(__self__, "auto_recording", auto_recording)
        if create_as_email is not None:
            pulumi.set(__self__, "create_as_email", create_as_email)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if record_meeting is not None:
            pulumi.set(__self__, "record_meeting", record_meeting)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def topic(self) -> str:
        """
        The meeting topic
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="alternativeHosts")
    def alternative_hosts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "alternative_hosts")

    @property
    @pulumi.getter(name="autoRecording")
    def auto_recording(self) -> Optional[str]:
        """
        Value must be one of `none`, `local`, `cloud`.
        """
        return pulumi.get(self, "auto_recording")

    @property
    @pulumi.getter(name="createAsEmail")
    def create_as_email(self) -> Optional[str]:
        """
        The email to use if creating as email
        """
        return pulumi.get(self, "create_as_email")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The meeting password
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskCreateZoomMeetingTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="recordMeeting")
    def record_meeting(self) -> Optional[bool]:
        """
        We will invite Rootly Bot to your call and make the transcript available to you. Value must be one of true or false
        """
        return pulumi.get(self, "record_meeting")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskCreateZoomMeetingTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskGetAlertsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pastDuration":
            suggest = "past_duration"
        elif key == "environmentIds":
            suggest = "environment_ids"
        elif key == "environmentsImpactedByIncident":
            suggest = "environments_impacted_by_incident"
        elif key == "parentMessageThreadTask":
            suggest = "parent_message_thread_task"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "serviceIds":
            suggest = "service_ids"
        elif key == "servicesImpactedByIncident":
            suggest = "services_impacted_by_incident"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskGetAlertsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskGetAlertsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskGetAlertsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 past_duration: str,
                 environment_ids: Optional[Sequence[str]] = None,
                 environments_impacted_by_incident: Optional[bool] = None,
                 labels: Optional[Sequence[str]] = None,
                 parent_message_thread_task: Optional[Mapping[str, str]] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskGetAlertsTaskParamsPostToSlackChannel']] = None,
                 service_ids: Optional[Sequence[str]] = None,
                 services_impacted_by_incident: Optional[bool] = None,
                 sources: Optional[Sequence[str]] = None,
                 task_type: Optional[str] = None):
        """
        :param str past_duration: How far back to fetch commits (in format '1 minute', '30 days', '3 months', etc.)
        :param bool environments_impacted_by_incident: Value must be one of true or false
        :param Mapping[str, str] parent_message_thread_task: Map must contain two fields, `id` and `name`. A hash where [id] is the task id of the parent task that sent a message, and [name] is the name of the parent task
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool services_impacted_by_incident: Value must be one of true or false
        """
        pulumi.set(__self__, "past_duration", past_duration)
        if environment_ids is not None:
            pulumi.set(__self__, "environment_ids", environment_ids)
        if environments_impacted_by_incident is not None:
            pulumi.set(__self__, "environments_impacted_by_incident", environments_impacted_by_incident)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if parent_message_thread_task is not None:
            pulumi.set(__self__, "parent_message_thread_task", parent_message_thread_task)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)
        if services_impacted_by_incident is not None:
            pulumi.set(__self__, "services_impacted_by_incident", services_impacted_by_incident)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="pastDuration")
    def past_duration(self) -> str:
        """
        How far back to fetch commits (in format '1 minute', '30 days', '3 months', etc.)
        """
        return pulumi.get(self, "past_duration")

    @property
    @pulumi.getter(name="environmentIds")
    def environment_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "environment_ids")

    @property
    @pulumi.getter(name="environmentsImpactedByIncident")
    def environments_impacted_by_incident(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "environments_impacted_by_incident")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="parentMessageThreadTask")
    def parent_message_thread_task(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. A hash where [id] is the task id of the parent task that sent a message, and [name] is the name of the parent task
        """
        return pulumi.get(self, "parent_message_thread_task")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskGetAlertsTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_ids")

    @property
    @pulumi.getter(name="servicesImpactedByIncident")
    def services_impacted_by_incident(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "services_impacted_by_incident")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskGetAlertsTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskGetGithubCommitsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pastDuration":
            suggest = "past_duration"
        elif key == "githubRepositoryNames":
            suggest = "github_repository_names"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "serviceIds":
            suggest = "service_ids"
        elif key == "servicesImpactedByIncident":
            suggest = "services_impacted_by_incident"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskGetGithubCommitsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskGetGithubCommitsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskGetGithubCommitsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: str,
                 past_duration: str,
                 github_repository_names: Optional[Sequence[str]] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskGetGithubCommitsTaskParamsPostToSlackChannel']] = None,
                 service_ids: Optional[Sequence[str]] = None,
                 services_impacted_by_incident: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param str branch: The branch
        :param str past_duration: How far back to fetch commits (in format '1 minute', '30 days', '3 months', etc.)
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool services_impacted_by_incident: Value must be one of true or false
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "past_duration", past_duration)
        if github_repository_names is not None:
            pulumi.set(__self__, "github_repository_names", github_repository_names)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)
        if services_impacted_by_incident is not None:
            pulumi.set(__self__, "services_impacted_by_incident", services_impacted_by_incident)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        The branch
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="pastDuration")
    def past_duration(self) -> str:
        """
        How far back to fetch commits (in format '1 minute', '30 days', '3 months', etc.)
        """
        return pulumi.get(self, "past_duration")

    @property
    @pulumi.getter(name="githubRepositoryNames")
    def github_repository_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "github_repository_names")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskGetGithubCommitsTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_ids")

    @property
    @pulumi.getter(name="servicesImpactedByIncident")
    def services_impacted_by_incident(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "services_impacted_by_incident")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskGetGithubCommitsTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskGetGitlabCommitsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pastDuration":
            suggest = "past_duration"
        elif key == "gitlabRepositoryNames":
            suggest = "gitlab_repository_names"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "serviceIds":
            suggest = "service_ids"
        elif key == "servicesImpactedByIncident":
            suggest = "services_impacted_by_incident"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskGetGitlabCommitsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskGetGitlabCommitsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskGetGitlabCommitsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: str,
                 past_duration: str,
                 gitlab_repository_names: Optional[Sequence[str]] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskGetGitlabCommitsTaskParamsPostToSlackChannel']] = None,
                 service_ids: Optional[Sequence[str]] = None,
                 services_impacted_by_incident: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param str branch: The branch
        :param str past_duration: How far back to fetch commits (in format '1 minute', '30 days', '3 months', etc.)
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool services_impacted_by_incident: Value must be one of true or false
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "past_duration", past_duration)
        if gitlab_repository_names is not None:
            pulumi.set(__self__, "gitlab_repository_names", gitlab_repository_names)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)
        if services_impacted_by_incident is not None:
            pulumi.set(__self__, "services_impacted_by_incident", services_impacted_by_incident)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        The branch
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="pastDuration")
    def past_duration(self) -> str:
        """
        How far back to fetch commits (in format '1 minute', '30 days', '3 months', etc.)
        """
        return pulumi.get(self, "past_duration")

    @property
    @pulumi.getter(name="gitlabRepositoryNames")
    def gitlab_repository_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "gitlab_repository_names")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskGetGitlabCommitsTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_ids")

    @property
    @pulumi.getter(name="servicesImpactedByIncident")
    def services_impacted_by_incident(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "services_impacted_by_incident")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskGetGitlabCommitsTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskGetPulsesTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pastDuration":
            suggest = "past_duration"
        elif key == "environmentIds":
            suggest = "environment_ids"
        elif key == "environmentsImpactedByIncident":
            suggest = "environments_impacted_by_incident"
        elif key == "parentMessageThreadTask":
            suggest = "parent_message_thread_task"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "serviceIds":
            suggest = "service_ids"
        elif key == "servicesImpactedByIncident":
            suggest = "services_impacted_by_incident"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskGetPulsesTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskGetPulsesTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskGetPulsesTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 past_duration: str,
                 environment_ids: Optional[Sequence[str]] = None,
                 environments_impacted_by_incident: Optional[bool] = None,
                 labels: Optional[Sequence[str]] = None,
                 parent_message_thread_task: Optional[Mapping[str, str]] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskGetPulsesTaskParamsPostToSlackChannel']] = None,
                 refs: Optional[Sequence[str]] = None,
                 service_ids: Optional[Sequence[str]] = None,
                 services_impacted_by_incident: Optional[bool] = None,
                 sources: Optional[Sequence[str]] = None,
                 task_type: Optional[str] = None):
        """
        :param str past_duration: How far back to fetch commits (in format '1 minute', '30 days', '3 months', etc.)
        :param bool environments_impacted_by_incident: Value must be one of true or false
        :param Mapping[str, str] parent_message_thread_task: Map must contain two fields, `id` and `name`. A hash where [id] is the task id of the parent task that sent a message, and [name] is the name of the parent task
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool services_impacted_by_incident: Value must be one of true or false
        """
        pulumi.set(__self__, "past_duration", past_duration)
        if environment_ids is not None:
            pulumi.set(__self__, "environment_ids", environment_ids)
        if environments_impacted_by_incident is not None:
            pulumi.set(__self__, "environments_impacted_by_incident", environments_impacted_by_incident)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if parent_message_thread_task is not None:
            pulumi.set(__self__, "parent_message_thread_task", parent_message_thread_task)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if refs is not None:
            pulumi.set(__self__, "refs", refs)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)
        if services_impacted_by_incident is not None:
            pulumi.set(__self__, "services_impacted_by_incident", services_impacted_by_incident)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="pastDuration")
    def past_duration(self) -> str:
        """
        How far back to fetch commits (in format '1 minute', '30 days', '3 months', etc.)
        """
        return pulumi.get(self, "past_duration")

    @property
    @pulumi.getter(name="environmentIds")
    def environment_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "environment_ids")

    @property
    @pulumi.getter(name="environmentsImpactedByIncident")
    def environments_impacted_by_incident(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "environments_impacted_by_incident")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="parentMessageThreadTask")
    def parent_message_thread_task(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. A hash where [id] is the task id of the parent task that sent a message, and [name] is the name of the parent task
        """
        return pulumi.get(self, "parent_message_thread_task")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskGetPulsesTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter
    def refs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "refs")

    @property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_ids")

    @property
    @pulumi.getter(name="servicesImpactedByIncident")
    def services_impacted_by_incident(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "services_impacted_by_incident")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskGetPulsesTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskHttpClientTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "succeedOnStatus":
            suggest = "succeed_on_status"
        elif key == "eventMessage":
            suggest = "event_message"
        elif key == "eventUrl":
            suggest = "event_url"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskHttpClientTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskHttpClientTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskHttpClientTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 succeed_on_status: str,
                 url: str,
                 body: Optional[str] = None,
                 event_message: Optional[str] = None,
                 event_url: Optional[str] = None,
                 headers: Optional[str] = None,
                 method: Optional[str] = None,
                 params: Optional[str] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskHttpClientTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param str succeed_on_status: HTTP status code expected. Can be a regular expression. Eg: 200, 200|203, 20[0-3]
        :param str url: URL endpoint
        :param str body: HTTP body
        :param str headers: JSON map of HTTP headers
        :param str method: HTTP method. Value must be one of `GET`, `POST`, `PATCH`, `PUT`, `DELETE`, `OPTIONS`.
        :param str params: JSON map of HTTP query parameters
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "succeed_on_status", succeed_on_status)
        pulumi.set(__self__, "url", url)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if event_message is not None:
            pulumi.set(__self__, "event_message", event_message)
        if event_url is not None:
            pulumi.set(__self__, "event_url", event_url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="succeedOnStatus")
    def succeed_on_status(self) -> str:
        """
        HTTP status code expected. Can be a regular expression. Eg: 200, 200|203, 20[0-3]
        """
        return pulumi.get(self, "succeed_on_status")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL endpoint
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        HTTP body
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="eventMessage")
    def event_message(self) -> Optional[str]:
        return pulumi.get(self, "event_message")

    @property
    @pulumi.getter(name="eventUrl")
    def event_url(self) -> Optional[str]:
        return pulumi.get(self, "event_url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[str]:
        """
        JSON map of HTTP headers
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        HTTP method. Value must be one of `GET`, `POST`, `PATCH`, `PUT`, `DELETE`, `OPTIONS`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def params(self) -> Optional[str]:
        """
        JSON map of HTTP query parameters
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskHttpClientTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskHttpClientTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelOpsgenieTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskInviteToSlackChannelOpsgenieTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskInviteToSlackChannelOpsgenieTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskInviteToSlackChannelOpsgenieTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule: Mapping[str, str],
                 channels: Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelOpsgenieTaskParamsChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] schedule: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "schedule", schedule)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def schedule(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelOpsgenieTaskParamsChannel']]:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelOpsgenieTaskParamsChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelPagerdutyTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationPolicy":
            suggest = "escalation_policy"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskInviteToSlackChannelPagerdutyTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskInviteToSlackChannelPagerdutyTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskInviteToSlackChannelPagerdutyTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channels: Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelPagerdutyTaskParamsChannel']] = None,
                 escalation_policy: Optional[Mapping[str, str]] = None,
                 schedule: Optional[Mapping[str, str]] = None,
                 service: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] escalation_policy: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] schedule: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] service: Map must contain two fields, `id` and `name`.
        """
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelPagerdutyTaskParamsChannel']]:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "escalation_policy")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def service(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelPagerdutyTaskParamsChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelRootlyTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationPolicyTarget":
            suggest = "escalation_policy_target"
        elif key == "groupTarget":
            suggest = "group_target"
        elif key == "scheduleTarget":
            suggest = "schedule_target"
        elif key == "serviceTarget":
            suggest = "service_target"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "userTarget":
            suggest = "user_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskInviteToSlackChannelRootlyTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskInviteToSlackChannelRootlyTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskInviteToSlackChannelRootlyTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channels: Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelRootlyTaskParamsChannel']] = None,
                 escalation_policy_target: Optional[Mapping[str, str]] = None,
                 group_target: Optional[Mapping[str, str]] = None,
                 schedule_target: Optional[Mapping[str, str]] = None,
                 service_target: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 user_target: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] escalation_policy_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] group_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] schedule_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] service_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] user_target: Map must contain two fields, `id` and `name`.
        """
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if escalation_policy_target is not None:
            pulumi.set(__self__, "escalation_policy_target", escalation_policy_target)
        if group_target is not None:
            pulumi.set(__self__, "group_target", group_target)
        if schedule_target is not None:
            pulumi.set(__self__, "schedule_target", schedule_target)
        if service_target is not None:
            pulumi.set(__self__, "service_target", service_target)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if user_target is not None:
            pulumi.set(__self__, "user_target", user_target)

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelRootlyTaskParamsChannel']]:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="escalationPolicyTarget")
    def escalation_policy_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "escalation_policy_target")

    @property
    @pulumi.getter(name="groupTarget")
    def group_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "group_target")

    @property
    @pulumi.getter(name="scheduleTarget")
    def schedule_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "schedule_target")

    @property
    @pulumi.getter(name="serviceTarget")
    def service_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "service_target")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="userTarget")
    def user_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "user_target")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelRootlyTaskParamsChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slackUserGroups":
            suggest = "slack_user_groups"
        elif key == "slackUsers":
            suggest = "slack_users"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskInviteToSlackChannelTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskInviteToSlackChannelTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskInviteToSlackChannelTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Mapping[str, str],
                 slack_user_groups: Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelTaskParamsSlackUserGroup']] = None,
                 slack_users: Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelTaskParamsSlackUser']] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] channel: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "channel", channel)
        if slack_user_groups is not None:
            pulumi.set(__self__, "slack_user_groups", slack_user_groups)
        if slack_users is not None:
            pulumi.set(__self__, "slack_users", slack_users)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def channel(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="slackUserGroups")
    def slack_user_groups(self) -> Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelTaskParamsSlackUserGroup']]:
        return pulumi.get(self, "slack_user_groups")

    @property
    @pulumi.getter(name="slackUsers")
    def slack_users(self) -> Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelTaskParamsSlackUser']]:
        return pulumi.get(self, "slack_users")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelTaskParamsSlackUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelTaskParamsSlackUserGroup(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelVictorOpsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskInviteToSlackChannelVictorOpsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskInviteToSlackChannelVictorOpsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskInviteToSlackChannelVictorOpsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 team: Mapping[str, str],
                 channels: Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelVictorOpsTaskParamsChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] team: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "team", team)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def team(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "team")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WorkflowTaskInviteToSlackChannelVictorOpsTaskParamsChannel']]:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskInviteToSlackChannelVictorOpsTaskParamsChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskPageOpsgenieOnCallRespondersTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskPageOpsgenieOnCallRespondersTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskPageOpsgenieOnCallRespondersTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskPageOpsgenieOnCallRespondersTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 message: Optional[str] = None,
                 priority: Optional[str] = None,
                 task_type: Optional[str] = None,
                 teams: Optional[Sequence['outputs.WorkflowTaskPageOpsgenieOnCallRespondersTaskParamsTeam']] = None,
                 title: Optional[str] = None,
                 users: Optional[Sequence['outputs.WorkflowTaskPageOpsgenieOnCallRespondersTaskParamsUser']] = None):
        """
        :param str description: Description field of the incident that is generally used to provide a detailed information about the incident
        :param str message: Message of the incident
        :param str priority: Value must be one of `P1`, `P2`, `P3`, `P4`, `P5`, `auto`.
        :param str title: Incident title.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description field of the incident that is generally used to provide a detailed information about the incident
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message of the incident
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        Value must be one of `P1`, `P2`, `P3`, `P4`, `P5`, `auto`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence['outputs.WorkflowTaskPageOpsgenieOnCallRespondersTaskParamsTeam']]:
        return pulumi.get(self, "teams")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Incident title.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.WorkflowTaskPageOpsgenieOnCallRespondersTaskParamsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class WorkflowTaskPageOpsgenieOnCallRespondersTaskParamsTeam(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskPageOpsgenieOnCallRespondersTaskParamsUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskPagePagerdutyOnCallRespondersTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createNewIncidentOnConflict":
            suggest = "create_new_incident_on_conflict"
        elif key == "escalationPolicies":
            suggest = "escalation_policies"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskPagePagerdutyOnCallRespondersTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskPagePagerdutyOnCallRespondersTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskPagePagerdutyOnCallRespondersTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: Mapping[str, str],
                 create_new_incident_on_conflict: Optional[bool] = None,
                 escalation_policies: Optional[Sequence['outputs.WorkflowTaskPagePagerdutyOnCallRespondersTaskParamsEscalationPolicy']] = None,
                 message: Optional[str] = None,
                 priority: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None,
                 urgency: Optional[str] = None,
                 users: Optional[Sequence['outputs.WorkflowTaskPagePagerdutyOnCallRespondersTaskParamsUser']] = None):
        """
        :param Mapping[str, str] service: Map must contain two fields, `id` and `name`.
        :param bool create_new_incident_on_conflict: Rootly only supports linking to a single PagerDuty incident. If this feature is disabled Rootly will add responders from any additional pages to the existing PagerDuty incident that is linked to the Rootly incident. If enabled, Rootly will create a new PagerDuty incident that is not linked to any Rootly incidents. Value must be one of true or false
        :param str priority: PagerDuty incident priority, selecting auto will let Rootly auto map our incident severity
        :param str title: Incident title.
        :param str urgency: Value must be one of `high`, `low`, `auto`.
        """
        pulumi.set(__self__, "service", service)
        if create_new_incident_on_conflict is not None:
            pulumi.set(__self__, "create_new_incident_on_conflict", create_new_incident_on_conflict)
        if escalation_policies is not None:
            pulumi.set(__self__, "escalation_policies", escalation_policies)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def service(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="createNewIncidentOnConflict")
    def create_new_incident_on_conflict(self) -> Optional[bool]:
        """
        Rootly only supports linking to a single PagerDuty incident. If this feature is disabled Rootly will add responders from any additional pages to the existing PagerDuty incident that is linked to the Rootly incident. If enabled, Rootly will create a new PagerDuty incident that is not linked to any Rootly incidents. Value must be one of true or false
        """
        return pulumi.get(self, "create_new_incident_on_conflict")

    @property
    @pulumi.getter(name="escalationPolicies")
    def escalation_policies(self) -> Optional[Sequence['outputs.WorkflowTaskPagePagerdutyOnCallRespondersTaskParamsEscalationPolicy']]:
        return pulumi.get(self, "escalation_policies")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        PagerDuty incident priority, selecting auto will let Rootly auto map our incident severity
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Incident title.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        Value must be one of `high`, `low`, `auto`.
        """
        return pulumi.get(self, "urgency")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.WorkflowTaskPagePagerdutyOnCallRespondersTaskParamsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class WorkflowTaskPagePagerdutyOnCallRespondersTaskParamsEscalationPolicy(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskPagePagerdutyOnCallRespondersTaskParamsUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskPageRootlyOnCallRespondersTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertUrgencyId":
            suggest = "alert_urgency_id"
        elif key == "escalationNote":
            suggest = "escalation_note"
        elif key == "escalationPolicyTarget":
            suggest = "escalation_policy_target"
        elif key == "groupTarget":
            suggest = "group_target"
        elif key == "serviceTarget":
            suggest = "service_target"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "userTarget":
            suggest = "user_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskPageRootlyOnCallRespondersTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskPageRootlyOnCallRespondersTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskPageRootlyOnCallRespondersTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 summary: str,
                 alert_urgency_id: Optional[str] = None,
                 escalation_note: Optional[str] = None,
                 escalation_policy_target: Optional[Mapping[str, str]] = None,
                 group_target: Optional[Mapping[str, str]] = None,
                 service_target: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 user_target: Optional[Mapping[str, str]] = None):
        """
        :param str alert_urgency_id: Alert urgency ID
        :param Mapping[str, str] escalation_policy_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] group_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] service_target: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] user_target: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "summary", summary)
        if alert_urgency_id is not None:
            pulumi.set(__self__, "alert_urgency_id", alert_urgency_id)
        if escalation_note is not None:
            pulumi.set(__self__, "escalation_note", escalation_note)
        if escalation_policy_target is not None:
            pulumi.set(__self__, "escalation_policy_target", escalation_policy_target)
        if group_target is not None:
            pulumi.set(__self__, "group_target", group_target)
        if service_target is not None:
            pulumi.set(__self__, "service_target", service_target)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if user_target is not None:
            pulumi.set(__self__, "user_target", user_target)

    @property
    @pulumi.getter
    def summary(self) -> str:
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="alertUrgencyId")
    def alert_urgency_id(self) -> Optional[str]:
        """
        Alert urgency ID
        """
        return pulumi.get(self, "alert_urgency_id")

    @property
    @pulumi.getter(name="escalationNote")
    def escalation_note(self) -> Optional[str]:
        return pulumi.get(self, "escalation_note")

    @property
    @pulumi.getter(name="escalationPolicyTarget")
    def escalation_policy_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "escalation_policy_target")

    @property
    @pulumi.getter(name="groupTarget")
    def group_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "group_target")

    @property
    @pulumi.getter(name="serviceTarget")
    def service_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "service_target")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="userTarget")
    def user_target(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "user_target")


@pulumi.output_type
class WorkflowTaskPageVictorOpsOnCallRespondersTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationPolicies":
            suggest = "escalation_policies"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskPageVictorOpsOnCallRespondersTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskPageVictorOpsOnCallRespondersTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskPageVictorOpsOnCallRespondersTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_policies: Optional[Sequence['outputs.WorkflowTaskPageVictorOpsOnCallRespondersTaskParamsEscalationPolicy']] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None,
                 users: Optional[Sequence['outputs.WorkflowTaskPageVictorOpsOnCallRespondersTaskParamsUser']] = None):
        """
        :param str title: Alert title.
        """
        if escalation_policies is not None:
            pulumi.set(__self__, "escalation_policies", escalation_policies)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="escalationPolicies")
    def escalation_policies(self) -> Optional[Sequence['outputs.WorkflowTaskPageVictorOpsOnCallRespondersTaskParamsEscalationPolicy']]:
        return pulumi.get(self, "escalation_policies")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Alert title.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.WorkflowTaskPageVictorOpsOnCallRespondersTaskParamsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class WorkflowTaskPageVictorOpsOnCallRespondersTaskParamsEscalationPolicy(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskPageVictorOpsOnCallRespondersTaskParamsUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskPrintTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskPrintTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskPrintTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskPrintTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 task_type: Optional[str] = None):
        """
        :param str message: The message to print
        """
        pulumi.set(__self__, "message", message)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The message to print
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskPublishIncidentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicTitle":
            suggest = "public_title"
        elif key == "statusPageId":
            suggest = "status_page_id"
        elif key == "integrationPayload":
            suggest = "integration_payload"
        elif key == "notifySubscribers":
            suggest = "notify_subscribers"
        elif key == "shouldTweet":
            suggest = "should_tweet"
        elif key == "statusPageTemplate":
            suggest = "status_page_template"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskPublishIncidentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskPublishIncidentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskPublishIncidentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident: Mapping[str, str],
                 public_title: str,
                 status: str,
                 status_page_id: str,
                 event: Optional[str] = None,
                 integration_payload: Optional[str] = None,
                 notify_subscribers: Optional[bool] = None,
                 should_tweet: Optional[bool] = None,
                 status_page_template: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] incident: Map must contain two fields, `id` and `name`.
        :param str status: Value must be one of `investigating`, `identified`, `monitoring`, `resolved`, `scheduled`, `in_progress`, `verifying`, `completed`.
        :param str event: Incident event description
        :param str integration_payload: Additional API Payload you can pass to statuspage.io for example. Can contain liquid markup and need to be valid JSON
        :param bool notify_subscribers: When true notifies subscribers of the status page by email/text. Value must be one of true or false
        :param bool should_tweet: For Statuspage.io integrated pages auto publishes a tweet for your update. Value must be one of true or false
        :param Mapping[str, str] status_page_template: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "incident", incident)
        pulumi.set(__self__, "public_title", public_title)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_page_id", status_page_id)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if integration_payload is not None:
            pulumi.set(__self__, "integration_payload", integration_payload)
        if notify_subscribers is not None:
            pulumi.set(__self__, "notify_subscribers", notify_subscribers)
        if should_tweet is not None:
            pulumi.set(__self__, "should_tweet", should_tweet)
        if status_page_template is not None:
            pulumi.set(__self__, "status_page_template", status_page_template)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def incident(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "incident")

    @property
    @pulumi.getter(name="publicTitle")
    def public_title(self) -> str:
        return pulumi.get(self, "public_title")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Value must be one of `investigating`, `identified`, `monitoring`, `resolved`, `scheduled`, `in_progress`, `verifying`, `completed`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusPageId")
    def status_page_id(self) -> str:
        return pulumi.get(self, "status_page_id")

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        Incident event description
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter(name="integrationPayload")
    def integration_payload(self) -> Optional[str]:
        """
        Additional API Payload you can pass to statuspage.io for example. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "integration_payload")

    @property
    @pulumi.getter(name="notifySubscribers")
    def notify_subscribers(self) -> Optional[bool]:
        """
        When true notifies subscribers of the status page by email/text. Value must be one of true or false
        """
        return pulumi.get(self, "notify_subscribers")

    @property
    @pulumi.getter(name="shouldTweet")
    def should_tweet(self) -> Optional[bool]:
        """
        For Statuspage.io integrated pages auto publishes a tweet for your update. Value must be one of true or false
        """
        return pulumi.get(self, "should_tweet")

    @property
    @pulumi.getter(name="statusPageTemplate")
    def status_page_template(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "status_page_template")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskRedisClientTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventMessage":
            suggest = "event_message"
        elif key == "eventUrl":
            suggest = "event_url"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskRedisClientTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskRedisClientTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskRedisClientTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: str,
                 url: str,
                 event_message: Optional[str] = None,
                 event_url: Optional[str] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskRedisClientTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "url", url)
        if event_message is not None:
            pulumi.set(__self__, "event_message", event_message)
        if event_url is not None:
            pulumi.set(__self__, "event_url", event_url)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def commands(self) -> str:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="eventMessage")
    def event_message(self) -> Optional[str]:
        return pulumi.get(self, "event_message")

    @property
    @pulumi.getter(name="eventUrl")
    def event_url(self) -> Optional[str]:
        return pulumi.get(self, "event_url")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskRedisClientTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskRedisClientTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskRemoveGoogleDocsPermissionsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeToQueryBy":
            suggest = "attribute_to_query_by"
        elif key == "fileId":
            suggest = "file_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskRemoveGoogleDocsPermissionsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskRemoveGoogleDocsPermissionsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskRemoveGoogleDocsPermissionsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_to_query_by: str,
                 file_id: str,
                 value: str,
                 task_type: Optional[str] = None):
        """
        :param str attribute_to_query_by: Value must be one of `type`, `role`, `email_address`.
        :param str file_id: The Google Doc file ID
        """
        pulumi.set(__self__, "attribute_to_query_by", attribute_to_query_by)
        pulumi.set(__self__, "file_id", file_id)
        pulumi.set(__self__, "value", value)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="attributeToQueryBy")
    def attribute_to_query_by(self) -> str:
        """
        Value must be one of `type`, `role`, `email_address`.
        """
        return pulumi.get(self, "attribute_to_query_by")

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> str:
        """
        The Google Doc file ID
        """
        return pulumi.get(self, "file_id")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskRenameSlackChannelTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskRenameSlackChannelTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskRenameSlackChannelTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskRenameSlackChannelTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Mapping[str, str],
                 title: str,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] channel: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "title", title)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def channel(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskRunCommandHerokuTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appName":
            suggest = "app_name"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskRunCommandHerokuTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskRunCommandHerokuTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskRunCommandHerokuTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_name: str,
                 command: str,
                 size: str,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskRunCommandHerokuTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param str size: Value must be one of `standard-1X`, `standard-2X`.
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "size", size)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> str:
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter
    def command(self) -> str:
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Value must be one of `standard-1X`, `standard-2X`.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskRunCommandHerokuTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskRunCommandHerokuTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSendDashboardReportTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardIds":
            suggest = "dashboard_ids"
        elif key == "from":
            suggest = "from_"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSendDashboardReportTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSendDashboardReportTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSendDashboardReportTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: str,
                 dashboard_ids: Sequence[str],
                 subject: str,
                 tos: Sequence[str],
                 from_: Optional[str] = None,
                 preheader: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str body: The email body
        :param str subject: The subject
        :param str from_: The from email address. Need to use SMTP integration if different than rootly.com
        :param str preheader: The preheader
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "dashboard_ids", dashboard_ids)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "tos", tos)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if preheader is not None:
            pulumi.set(__self__, "preheader", preheader)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The email body
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="dashboardIds")
    def dashboard_ids(self) -> Sequence[str]:
        return pulumi.get(self, "dashboard_ids")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def tos(self) -> Sequence[str]:
        return pulumi.get(self, "tos")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        """
        The from email address. Need to use SMTP integration if different than rootly.com
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def preheader(self) -> Optional[str]:
        """
        The preheader
        """
        return pulumi.get(self, "preheader")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskSendEmailTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLogoUrl":
            suggest = "custom_logo_url"
        elif key == "from":
            suggest = "from_"
        elif key == "includeFooter":
            suggest = "include_footer"
        elif key == "includeHeader":
            suggest = "include_header"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSendEmailTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSendEmailTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSendEmailTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: str,
                 subject: str,
                 tos: Sequence[str],
                 bccs: Optional[Sequence[str]] = None,
                 ccs: Optional[Sequence[str]] = None,
                 custom_logo_url: Optional[str] = None,
                 from_: Optional[str] = None,
                 include_footer: Optional[bool] = None,
                 include_header: Optional[bool] = None,
                 preheader: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str body: The email body
        :param str subject: The subject
        :param str custom_logo_url: URL to your custom email logo
        :param str from_: The from email address. Need to use SMTP integration if different than rootly.com
        :param bool include_footer: Value must be one of true or false
        :param bool include_header: Value must be one of true or false
        :param str preheader: The preheader
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "tos", tos)
        if bccs is not None:
            pulumi.set(__self__, "bccs", bccs)
        if ccs is not None:
            pulumi.set(__self__, "ccs", ccs)
        if custom_logo_url is not None:
            pulumi.set(__self__, "custom_logo_url", custom_logo_url)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if include_footer is not None:
            pulumi.set(__self__, "include_footer", include_footer)
        if include_header is not None:
            pulumi.set(__self__, "include_header", include_header)
        if preheader is not None:
            pulumi.set(__self__, "preheader", preheader)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The email body
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def tos(self) -> Sequence[str]:
        return pulumi.get(self, "tos")

    @property
    @pulumi.getter
    def bccs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bccs")

    @property
    @pulumi.getter
    def ccs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ccs")

    @property
    @pulumi.getter(name="customLogoUrl")
    def custom_logo_url(self) -> Optional[str]:
        """
        URL to your custom email logo
        """
        return pulumi.get(self, "custom_logo_url")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        """
        The from email address. Need to use SMTP integration if different than rootly.com
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter(name="includeFooter")
    def include_footer(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "include_footer")

    @property
    @pulumi.getter(name="includeHeader")
    def include_header(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "include_header")

    @property
    @pulumi.getter
    def preheader(self) -> Optional[str]:
        """
        The preheader
        """
        return pulumi.get(self, "preheader")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskSendSlackBlocksTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "broadcastThreadReplyToChannel":
            suggest = "broadcast_thread_reply_to_channel"
        elif key == "parentMessageThreadTask":
            suggest = "parent_message_thread_task"
        elif key == "pinToChannel":
            suggest = "pin_to_channel"
        elif key == "sendAsEphemeral":
            suggest = "send_as_ephemeral"
        elif key == "sendOnlyAsThreadedMessage":
            suggest = "send_only_as_threaded_message"
        elif key == "slackUserGroups":
            suggest = "slack_user_groups"
        elif key == "slackUsers":
            suggest = "slack_users"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "updateParentMessage":
            suggest = "update_parent_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSendSlackBlocksTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSendSlackBlocksTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSendSlackBlocksTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocks: str,
                 attachments: Optional[str] = None,
                 broadcast_thread_reply_to_channel: Optional[bool] = None,
                 channels: Optional[Sequence['outputs.WorkflowTaskSendSlackBlocksTaskParamsChannel']] = None,
                 message: Optional[str] = None,
                 parent_message_thread_task: Optional[Mapping[str, str]] = None,
                 pin_to_channel: Optional[bool] = None,
                 send_as_ephemeral: Optional[bool] = None,
                 send_only_as_threaded_message: Optional[bool] = None,
                 slack_user_groups: Optional[Sequence['outputs.WorkflowTaskSendSlackBlocksTaskParamsSlackUserGroup']] = None,
                 slack_users: Optional[Sequence['outputs.WorkflowTaskSendSlackBlocksTaskParamsSlackUser']] = None,
                 task_type: Optional[str] = None,
                 update_parent_message: Optional[bool] = None):
        """
        :param str blocks: Support liquid markup. Needs to be a valid JSON string after liquid is parsed
        :param str attachments: Support liquid markup. Needs to be a valid JSON string after liquid is parsed
        :param bool broadcast_thread_reply_to_channel: Value must be one of true or false
        :param Mapping[str, str] parent_message_thread_task: Map must contain two fields, `id` and `name`. A hash where [id] is the task id of the parent task that sent a message, and [name] is the name of the parent task
        :param bool pin_to_channel: Value must be one of true or false
        :param bool send_as_ephemeral: Value must be one of true or false
        :param bool send_only_as_threaded_message: When set to true, if the parent for this threaded message cannot be found the message will be skipped.. Value must be one of true or false
        :param bool update_parent_message: Value must be one of true or false
        """
        pulumi.set(__self__, "blocks", blocks)
        if attachments is not None:
            pulumi.set(__self__, "attachments", attachments)
        if broadcast_thread_reply_to_channel is not None:
            pulumi.set(__self__, "broadcast_thread_reply_to_channel", broadcast_thread_reply_to_channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_message_thread_task is not None:
            pulumi.set(__self__, "parent_message_thread_task", parent_message_thread_task)
        if pin_to_channel is not None:
            pulumi.set(__self__, "pin_to_channel", pin_to_channel)
        if send_as_ephemeral is not None:
            pulumi.set(__self__, "send_as_ephemeral", send_as_ephemeral)
        if send_only_as_threaded_message is not None:
            pulumi.set(__self__, "send_only_as_threaded_message", send_only_as_threaded_message)
        if slack_user_groups is not None:
            pulumi.set(__self__, "slack_user_groups", slack_user_groups)
        if slack_users is not None:
            pulumi.set(__self__, "slack_users", slack_users)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if update_parent_message is not None:
            pulumi.set(__self__, "update_parent_message", update_parent_message)

    @property
    @pulumi.getter
    def blocks(self) -> str:
        """
        Support liquid markup. Needs to be a valid JSON string after liquid is parsed
        """
        return pulumi.get(self, "blocks")

    @property
    @pulumi.getter
    def attachments(self) -> Optional[str]:
        """
        Support liquid markup. Needs to be a valid JSON string after liquid is parsed
        """
        return pulumi.get(self, "attachments")

    @property
    @pulumi.getter(name="broadcastThreadReplyToChannel")
    def broadcast_thread_reply_to_channel(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "broadcast_thread_reply_to_channel")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WorkflowTaskSendSlackBlocksTaskParamsChannel']]:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="parentMessageThreadTask")
    def parent_message_thread_task(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. A hash where [id] is the task id of the parent task that sent a message, and [name] is the name of the parent task
        """
        return pulumi.get(self, "parent_message_thread_task")

    @property
    @pulumi.getter(name="pinToChannel")
    def pin_to_channel(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "pin_to_channel")

    @property
    @pulumi.getter(name="sendAsEphemeral")
    def send_as_ephemeral(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "send_as_ephemeral")

    @property
    @pulumi.getter(name="sendOnlyAsThreadedMessage")
    def send_only_as_threaded_message(self) -> Optional[bool]:
        """
        When set to true, if the parent for this threaded message cannot be found the message will be skipped.. Value must be one of true or false
        """
        return pulumi.get(self, "send_only_as_threaded_message")

    @property
    @pulumi.getter(name="slackUserGroups")
    def slack_user_groups(self) -> Optional[Sequence['outputs.WorkflowTaskSendSlackBlocksTaskParamsSlackUserGroup']]:
        return pulumi.get(self, "slack_user_groups")

    @property
    @pulumi.getter(name="slackUsers")
    def slack_users(self) -> Optional[Sequence['outputs.WorkflowTaskSendSlackBlocksTaskParamsSlackUser']]:
        return pulumi.get(self, "slack_users")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="updateParentMessage")
    def update_parent_message(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "update_parent_message")


@pulumi.output_type
class WorkflowTaskSendSlackBlocksTaskParamsChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSendSlackBlocksTaskParamsSlackUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSendSlackBlocksTaskParamsSlackUserGroup(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSendSlackMessageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "broadcastThreadReplyToChannel":
            suggest = "broadcast_thread_reply_to_channel"
        elif key == "parentMessageThreadTask":
            suggest = "parent_message_thread_task"
        elif key == "pinToChannel":
            suggest = "pin_to_channel"
        elif key == "sendAsEphemeral":
            suggest = "send_as_ephemeral"
        elif key == "sendOnlyAsThreadedMessage":
            suggest = "send_only_as_threaded_message"
        elif key == "slackUserGroups":
            suggest = "slack_user_groups"
        elif key == "slackUsers":
            suggest = "slack_users"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "updateParentMessage":
            suggest = "update_parent_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSendSlackMessageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSendSlackMessageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSendSlackMessageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: str,
                 actionables: Optional[Sequence[str]] = None,
                 broadcast_thread_reply_to_channel: Optional[bool] = None,
                 channels: Optional[Sequence['outputs.WorkflowTaskSendSlackMessageTaskParamsChannel']] = None,
                 color: Optional[str] = None,
                 parent_message_thread_task: Optional[Mapping[str, str]] = None,
                 pin_to_channel: Optional[bool] = None,
                 send_as_ephemeral: Optional[bool] = None,
                 send_only_as_threaded_message: Optional[bool] = None,
                 slack_user_groups: Optional[Sequence['outputs.WorkflowTaskSendSlackMessageTaskParamsSlackUserGroup']] = None,
                 slack_users: Optional[Sequence['outputs.WorkflowTaskSendSlackMessageTaskParamsSlackUser']] = None,
                 task_type: Optional[str] = None,
                 update_parent_message: Optional[bool] = None):
        """
        :param str text: The message text
        :param Sequence[str] actionables: Value must be one of `update_summary`, `update_status`, `archive_channel`, `manage_incident_roles`, `update_incident`, `all_commands`, `leave_feedback`, `manage_form_fields`, `manage_action_items`, `view_tasks`, `add_pagerduty_responders`, `add_opsgenie_responders`, `add_victor_ops_responders`, `snooze_reminder`, `pause_reminder`, `restart_reminder`, `update_status_page`, `cancel_incident`.
        :param bool broadcast_thread_reply_to_channel: Value must be one of true or false
        :param str color: A hex color
        :param Mapping[str, str] parent_message_thread_task: Map must contain two fields, `id` and `name`. A hash where [id] is the task id of the parent task that sent a message, and [name] is the name of the parent task
        :param bool pin_to_channel: Value must be one of true or false
        :param bool send_as_ephemeral: Value must be one of true or false
        :param bool send_only_as_threaded_message: When set to true, if the parent for this threaded message cannot be found the message will be skipped.. Value must be one of true or false
        :param bool update_parent_message: Value must be one of true or false
        """
        pulumi.set(__self__, "text", text)
        if actionables is not None:
            pulumi.set(__self__, "actionables", actionables)
        if broadcast_thread_reply_to_channel is not None:
            pulumi.set(__self__, "broadcast_thread_reply_to_channel", broadcast_thread_reply_to_channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if parent_message_thread_task is not None:
            pulumi.set(__self__, "parent_message_thread_task", parent_message_thread_task)
        if pin_to_channel is not None:
            pulumi.set(__self__, "pin_to_channel", pin_to_channel)
        if send_as_ephemeral is not None:
            pulumi.set(__self__, "send_as_ephemeral", send_as_ephemeral)
        if send_only_as_threaded_message is not None:
            pulumi.set(__self__, "send_only_as_threaded_message", send_only_as_threaded_message)
        if slack_user_groups is not None:
            pulumi.set(__self__, "slack_user_groups", slack_user_groups)
        if slack_users is not None:
            pulumi.set(__self__, "slack_users", slack_users)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if update_parent_message is not None:
            pulumi.set(__self__, "update_parent_message", update_parent_message)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The message text
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def actionables(self) -> Optional[Sequence[str]]:
        """
        Value must be one of `update_summary`, `update_status`, `archive_channel`, `manage_incident_roles`, `update_incident`, `all_commands`, `leave_feedback`, `manage_form_fields`, `manage_action_items`, `view_tasks`, `add_pagerduty_responders`, `add_opsgenie_responders`, `add_victor_ops_responders`, `snooze_reminder`, `pause_reminder`, `restart_reminder`, `update_status_page`, `cancel_incident`.
        """
        return pulumi.get(self, "actionables")

    @property
    @pulumi.getter(name="broadcastThreadReplyToChannel")
    def broadcast_thread_reply_to_channel(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "broadcast_thread_reply_to_channel")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WorkflowTaskSendSlackMessageTaskParamsChannel']]:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        A hex color
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="parentMessageThreadTask")
    def parent_message_thread_task(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. A hash where [id] is the task id of the parent task that sent a message, and [name] is the name of the parent task
        """
        return pulumi.get(self, "parent_message_thread_task")

    @property
    @pulumi.getter(name="pinToChannel")
    def pin_to_channel(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "pin_to_channel")

    @property
    @pulumi.getter(name="sendAsEphemeral")
    def send_as_ephemeral(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "send_as_ephemeral")

    @property
    @pulumi.getter(name="sendOnlyAsThreadedMessage")
    def send_only_as_threaded_message(self) -> Optional[bool]:
        """
        When set to true, if the parent for this threaded message cannot be found the message will be skipped.. Value must be one of true or false
        """
        return pulumi.get(self, "send_only_as_threaded_message")

    @property
    @pulumi.getter(name="slackUserGroups")
    def slack_user_groups(self) -> Optional[Sequence['outputs.WorkflowTaskSendSlackMessageTaskParamsSlackUserGroup']]:
        return pulumi.get(self, "slack_user_groups")

    @property
    @pulumi.getter(name="slackUsers")
    def slack_users(self) -> Optional[Sequence['outputs.WorkflowTaskSendSlackMessageTaskParamsSlackUser']]:
        return pulumi.get(self, "slack_users")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="updateParentMessage")
    def update_parent_message(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "update_parent_message")


@pulumi.output_type
class WorkflowTaskSendSlackMessageTaskParamsChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSendSlackMessageTaskParamsSlackUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSendSlackMessageTaskParamsSlackUserGroup(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSendSmsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumbers":
            suggest = "phone_numbers"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSendSmsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSendSmsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSendSmsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 name: str,
                 phone_numbers: Sequence[str],
                 task_type: Optional[str] = None):
        """
        :param str content: The SMS message
        :param str name: The name
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_numbers", phone_numbers)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The SMS message
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumbers")
    def phone_numbers(self) -> Sequence[str]:
        return pulumi.get(self, "phone_numbers")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskSendWhatsappMessageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumbers":
            suggest = "phone_numbers"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSendWhatsappMessageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSendWhatsappMessageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSendWhatsappMessageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 name: str,
                 phone_numbers: Sequence[str],
                 task_type: Optional[str] = None):
        """
        :param str content: The WhatsApp message
        :param str name: The name
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_numbers", phone_numbers)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The WhatsApp message
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumbers")
    def phone_numbers(self) -> Sequence[str]:
        return pulumi.get(self, "phone_numbers")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskSnapshotDatadogGraphTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pastDuration":
            suggest = "past_duration"
        elif key == "metricQueries":
            suggest = "metric_queries"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSnapshotDatadogGraphTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSnapshotDatadogGraphTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSnapshotDatadogGraphTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 past_duration: str,
                 dashboards: Optional[Sequence['outputs.WorkflowTaskSnapshotDatadogGraphTaskParamsDashboard']] = None,
                 metric_queries: Optional[Sequence[str]] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskSnapshotDatadogGraphTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param str past_duration: in format '1 minute', '30 days', '3 months', etc
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "past_duration", past_duration)
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if metric_queries is not None:
            pulumi.set(__self__, "metric_queries", metric_queries)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="pastDuration")
    def past_duration(self) -> str:
        """
        in format '1 minute', '30 days', '3 months', etc
        """
        return pulumi.get(self, "past_duration")

    @property
    @pulumi.getter
    def dashboards(self) -> Optional[Sequence['outputs.WorkflowTaskSnapshotDatadogGraphTaskParamsDashboard']]:
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="metricQueries")
    def metric_queries(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "metric_queries")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskSnapshotDatadogGraphTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskSnapshotDatadogGraphTaskParamsDashboard(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSnapshotDatadogGraphTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSnapshotGrafanaDashboardTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSnapshotGrafanaDashboardTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSnapshotGrafanaDashboardTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSnapshotGrafanaDashboardTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Sequence['outputs.WorkflowTaskSnapshotGrafanaDashboardTaskParamsDashboard'],
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskSnapshotGrafanaDashboardTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "dashboards", dashboards)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def dashboards(self) -> Sequence['outputs.WorkflowTaskSnapshotGrafanaDashboardTaskParamsDashboard']:
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskSnapshotGrafanaDashboardTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskSnapshotGrafanaDashboardTaskParamsDashboard(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSnapshotGrafanaDashboardTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSnapshotLookerLookTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSnapshotLookerLookTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSnapshotLookerLookTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSnapshotLookerLookTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Sequence['outputs.WorkflowTaskSnapshotLookerLookTaskParamsDashboard'],
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskSnapshotLookerLookTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "dashboards", dashboards)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def dashboards(self) -> Sequence['outputs.WorkflowTaskSnapshotLookerLookTaskParamsDashboard']:
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskSnapshotLookerLookTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskSnapshotLookerLookTaskParamsDashboard(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSnapshotLookerLookTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskSnapshotNewRelicGraphTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricQuery":
            suggest = "metric_query"
        elif key == "metricType":
            suggest = "metric_type"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskSnapshotNewRelicGraphTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskSnapshotNewRelicGraphTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskSnapshotNewRelicGraphTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_query: str,
                 metric_type: str,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskSnapshotNewRelicGraphTaskParamsPostToSlackChannel']] = None,
                 task_type: Optional[str] = None):
        """
        :param str metric_type: Value must be one of `APDEX`, `AREA`, `BAR`, `BASELINE`, `BILLBOARD`, `BULLET`, `EVENT_FEED`, `FUNNEL`, `HEATMAP`, `HISTOGRAM`, `LINE`, `PIE`, `SCATTER`, `STACKED_HORIZONTAL_BAR`, `TABLE`, `VERTICAL_BAR`.
        :param bool post_to_incident_timeline: Value must be one of true or false
        """
        pulumi.set(__self__, "metric_query", metric_query)
        pulumi.set(__self__, "metric_type", metric_type)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> str:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Value must be one of `APDEX`, `AREA`, `BAR`, `BASELINE`, `BILLBOARD`, `BULLET`, `EVENT_FEED`, `FUNNEL`, `HEATMAP`, `HISTOGRAM`, `LINE`, `PIE`, `SCATTER`, `STACKED_HORIZONTAL_BAR`, `TABLE`, `VERTICAL_BAR`.
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskSnapshotNewRelicGraphTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskSnapshotNewRelicGraphTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskTriggerWorkflowTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeToQueryBy":
            suggest = "attribute_to_query_by"
        elif key == "checkWorkflowConditions":
            suggest = "check_workflow_conditions"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskTriggerWorkflowTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskTriggerWorkflowTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskTriggerWorkflowTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_to_query_by: str,
                 kind: str,
                 resource: Mapping[str, str],
                 workflow: Mapping[str, str],
                 check_workflow_conditions: Optional[bool] = None,
                 task_type: Optional[str] = None):
        """
        :param str attribute_to_query_by: ["(incident) kind can only match [:id, :slug, :sequential*id, :pagerduty*incident*id, :opsgenie*incident*id, :victor*ops*incident*id, :jira*issue*id, :asana*task*id, :shortcut*task*id, :linear*issue*id, :zendesk*ticket*id, :trello*card*id, :airtable*record*id, :shortcut*story*id, :github*issue*id, :freshservice*ticket*id, :freshservice*task*id, :clickup*task*id]", "(post*mortem) kind can only match [:id]", "(action*item) kind can only match [:id, :jira*issue*id, :asana*task*id, :shortcut*task*id, :linear*issue*id, :zendesk*ticket*id, :trello*card*id, :airtable*record*id, :shortcut*story*id, :github*issue*id, :freshservice*ticket*id, :freshservice*task*id, :clickup*task*id]", "(pulse) kind can only match [:id]", "(alert) kind can only match [:id]"]. Value must be one of `id`, `slug`, `sequential_id`, `pagerduty_incident_id`, `opsgenie_incident_id`, `victor_ops_incident_id`, `jira_issue_id`, `asana_task_id`, `shortcut_task_id`, `linear_issue_id`, `zendesk_ticket_id`, `trello_card_id`, `airtable_record_id`, `shortcut_story_id`, `github_issue_id`, `freshservice_ticket_id`, `freshservice_task_id`, `clickup_task_id`.
        :param str kind: Value must be one of `incident`, `post_mortem`, `action_item`, `pulse`, `alert`.
        :param Mapping[str, str] resource: Map must contain two fields, `id` and `name`.
        :param Mapping[str, str] workflow: Map must contain two fields, `id` and `name`.
        :param bool check_workflow_conditions: Value must be one of true or false
        """
        pulumi.set(__self__, "attribute_to_query_by", attribute_to_query_by)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "workflow", workflow)
        if check_workflow_conditions is not None:
            pulumi.set(__self__, "check_workflow_conditions", check_workflow_conditions)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="attributeToQueryBy")
    def attribute_to_query_by(self) -> str:
        """
        ["(incident) kind can only match [:id, :slug, :sequential*id, :pagerduty*incident*id, :opsgenie*incident*id, :victor*ops*incident*id, :jira*issue*id, :asana*task*id, :shortcut*task*id, :linear*issue*id, :zendesk*ticket*id, :trello*card*id, :airtable*record*id, :shortcut*story*id, :github*issue*id, :freshservice*ticket*id, :freshservice*task*id, :clickup*task*id]", "(post*mortem) kind can only match [:id]", "(action*item) kind can only match [:id, :jira*issue*id, :asana*task*id, :shortcut*task*id, :linear*issue*id, :zendesk*ticket*id, :trello*card*id, :airtable*record*id, :shortcut*story*id, :github*issue*id, :freshservice*ticket*id, :freshservice*task*id, :clickup*task*id]", "(pulse) kind can only match [:id]", "(alert) kind can only match [:id]"]. Value must be one of `id`, `slug`, `sequential_id`, `pagerduty_incident_id`, `opsgenie_incident_id`, `victor_ops_incident_id`, `jira_issue_id`, `asana_task_id`, `shortcut_task_id`, `linear_issue_id`, `zendesk_ticket_id`, `trello_card_id`, `airtable_record_id`, `shortcut_story_id`, `github_issue_id`, `freshservice_ticket_id`, `freshservice_task_id`, `clickup_task_id`.
        """
        return pulumi.get(self, "attribute_to_query_by")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Value must be one of `incident`, `post_mortem`, `action_item`, `pulse`, `alert`.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def resource(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def workflow(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "workflow")

    @property
    @pulumi.getter(name="checkWorkflowConditions")
    def check_workflow_conditions(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "check_workflow_conditions")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskTweetTwitterMessageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskTweetTwitterMessageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskTweetTwitterMessageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskTweetTwitterMessageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 task_type: Optional[str] = None):
        pulumi.set(__self__, "message", message)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def message(self) -> str:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateActionItemTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeToQueryBy":
            suggest = "attribute_to_query_by"
        elif key == "queryValue":
            suggest = "query_value"
        elif key == "assignedToUser":
            suggest = "assigned_to_user"
        elif key == "assignedToUserId":
            suggest = "assigned_to_user_id"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "groupIds":
            suggest = "group_ids"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateActionItemTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateActionItemTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateActionItemTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_to_query_by: str,
                 query_value: str,
                 assigned_to_user: Optional[Mapping[str, str]] = None,
                 assigned_to_user_id: Optional[str] = None,
                 custom_fields_mapping: Optional[str] = None,
                 description: Optional[str] = None,
                 group_ids: Optional[Sequence[str]] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 priority: Optional[str] = None,
                 status: Optional[str] = None,
                 summary: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str attribute_to_query_by: Attribute of the action item to match against. Value must be one of `id`, `jira_issue_id`, `asana_task_id`, `shortcut_task_id`, `linear_issue_id`, `zendesk_ticket_id`, `trello_card_id`, `airtable_record_id`, `shortcut_story_id`, `github_issue_id`, `gitlab_issue_id`, `freshservice_ticket_id`, `freshservice_task_id`, `clickup_task_id`.
        :param str query_value: Value that attribute*to*query_by to uses to match against
        :param Mapping[str, str] assigned_to_user: Map must contain two fields, `id` and `name`.  The user this action item is assigned to
        :param str assigned_to_user_id: [DEPRECATED] Use assigned*to*user attribute instead. The user id this action item is assigned to
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str description: The action item description
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param str priority: The action item priority. Value must be one of `high`, `medium`, `low`.
        :param str status: The action item status. Value must be one of `open`, `in_progress`, `cancelled`, `done`.
        :param str summary: Brief description of the action item
        """
        pulumi.set(__self__, "attribute_to_query_by", attribute_to_query_by)
        pulumi.set(__self__, "query_value", query_value)
        if assigned_to_user is not None:
            pulumi.set(__self__, "assigned_to_user", assigned_to_user)
        if assigned_to_user_id is not None:
            pulumi.set(__self__, "assigned_to_user_id", assigned_to_user_id)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="attributeToQueryBy")
    def attribute_to_query_by(self) -> str:
        """
        Attribute of the action item to match against. Value must be one of `id`, `jira_issue_id`, `asana_task_id`, `shortcut_task_id`, `linear_issue_id`, `zendesk_ticket_id`, `trello_card_id`, `airtable_record_id`, `shortcut_story_id`, `github_issue_id`, `gitlab_issue_id`, `freshservice_ticket_id`, `freshservice_task_id`, `clickup_task_id`.
        """
        return pulumi.get(self, "attribute_to_query_by")

    @property
    @pulumi.getter(name="queryValue")
    def query_value(self) -> str:
        """
        Value that attribute*to*query_by to uses to match against
        """
        return pulumi.get(self, "query_value")

    @property
    @pulumi.getter(name="assignedToUser")
    def assigned_to_user(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`.  The user this action item is assigned to
        """
        return pulumi.get(self, "assigned_to_user")

    @property
    @pulumi.getter(name="assignedToUserId")
    def assigned_to_user_id(self) -> Optional[str]:
        """
        [DEPRECATED] Use assigned*to*user attribute instead. The user id this action item is assigned to
        """
        return pulumi.get(self, "assigned_to_user_id")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The action item description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        The action item priority. Value must be one of `high`, `medium`, `low`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The action item status. Value must be one of `open`, `in_progress`, `cancelled`, `done`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        Brief description of the action item
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateAirtableTableRecordTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseKey":
            suggest = "base_key"
        elif key == "recordId":
            suggest = "record_id"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateAirtableTableRecordTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateAirtableTableRecordTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateAirtableTableRecordTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_key: str,
                 record_id: str,
                 table_name: str,
                 custom_fields_mapping: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str base_key: The base key
        :param str record_id: The record id
        :param str table_name: The table name
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        pulumi.set(__self__, "base_key", base_key)
        pulumi.set(__self__, "record_id", record_id)
        pulumi.set(__self__, "table_name", table_name)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="baseKey")
    def base_key(self) -> str:
        """
        The base key
        """
        return pulumi.get(self, "base_key")

    @property
    @pulumi.getter(name="recordId")
    def record_id(self) -> str:
        """
        The record id
        """
        return pulumi.get(self, "record_id")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The table name
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateAsanaTaskTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskId":
            suggest = "task_id"
        elif key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "dependencyDirection":
            suggest = "dependency_direction"
        elif key == "dependentTaskIds":
            suggest = "dependent_task_ids"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateAsanaTaskTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateAsanaTaskTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateAsanaTaskTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completion: Mapping[str, str],
                 task_id: str,
                 assign_user_email: Optional[str] = None,
                 custom_fields_mapping: Optional[str] = None,
                 dependency_direction: Optional[str] = None,
                 dependent_task_ids: Optional[Sequence[str]] = None,
                 due_date: Optional[str] = None,
                 notes: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`.
        :param str task_id: The task id
        :param str assign_user_email: The assigned user's email
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str dependency_direction: Value must be one of `blocking`, `blocked_by`.
        :param Sequence[str] dependent_task_ids: Dependent task ids. Supports liquid syntax
        :param str due_date: The due date
        :param str title: The task title
        """
        pulumi.set(__self__, "completion", completion)
        pulumi.set(__self__, "task_id", task_id)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if dependency_direction is not None:
            pulumi.set(__self__, "dependency_direction", dependency_direction)
        if dependent_task_ids is not None:
            pulumi.set(__self__, "dependent_task_ids", dependent_task_ids)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def completion(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> str:
        """
        The task id
        """
        return pulumi.get(self, "task_id")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter(name="dependencyDirection")
    def dependency_direction(self) -> Optional[str]:
        """
        Value must be one of `blocking`, `blocked_by`.
        """
        return pulumi.get(self, "dependency_direction")

    @property
    @pulumi.getter(name="dependentTaskIds")
    def dependent_task_ids(self) -> Optional[Sequence[str]]:
        """
        Dependent task ids. Supports liquid syntax
        """
        return pulumi.get(self, "dependent_task_ids")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def notes(self) -> Optional[str]:
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The task title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateAttachedAlertsTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateAttachedAlertsTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateAttachedAlertsTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateAttachedAlertsTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 task_type: Optional[str] = None):
        """
        :param str status: Value must be one of `acknowledged`, `resolved`.
        """
        pulumi.set(__self__, "status", status)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Value must be one of `acknowledged`, `resolved`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateClickupTaskTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskId":
            suggest = "task_id"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "taskPayload":
            suggest = "task_payload"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateClickupTaskTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateClickupTaskTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateClickupTaskTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_id: str,
                 custom_fields_mapping: Optional[str] = None,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 tags: Optional[str] = None,
                 task_payload: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str task_id: The task id
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str description: The task description
        :param str due_date: The due date
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param str tags: The task tags
        :param str task_payload: Additional ClickUp task attributes. Will be merged into whatever was specified in this tasks current parameters. Can contain liquid markup and need to be valid JSON
        :param str title: The task title
        """
        pulumi.set(__self__, "task_id", task_id)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_payload is not None:
            pulumi.set(__self__, "task_payload", task_payload)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> str:
        """
        The task id
        """
        return pulumi.get(self, "task_id")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The task description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def tags(self) -> Optional[str]:
        """
        The task tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="taskPayload")
    def task_payload(self) -> Optional[str]:
        """
        Additional ClickUp task attributes. Will be merged into whatever was specified in this tasks current parameters. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "task_payload")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The task title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateGithubIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issueId":
            suggest = "issue_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateGithubIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateGithubIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateGithubIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completion: Mapping[str, str],
                 issue_id: str,
                 body: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`.
        :param str issue_id: The issue id
        :param str body: The issue body
        :param str title: The issue title
        """
        pulumi.set(__self__, "completion", completion)
        pulumi.set(__self__, "issue_id", issue_id)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def completion(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="issueId")
    def issue_id(self) -> str:
        """
        The issue id
        """
        return pulumi.get(self, "issue_id")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The issue body
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The issue title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateGitlabIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issueId":
            suggest = "issue_id"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "issueType":
            suggest = "issue_type"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateGitlabIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateGitlabIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateGitlabIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completion: Mapping[str, str],
                 issue_id: str,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 issue_type: Optional[str] = None,
                 labels: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`.
        :param str issue_id: The issue id
        :param str description: The issue description
        :param str due_date: The due date
        :param str issue_type: The issue type. Value must be one of `issue`, `incident`, `test_case`, `task`.
        :param str labels: The issue labels
        :param str title: The issue title
        """
        pulumi.set(__self__, "completion", completion)
        pulumi.set(__self__, "issue_id", issue_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if issue_type is not None:
            pulumi.set(__self__, "issue_type", issue_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def completion(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="issueId")
    def issue_id(self) -> str:
        """
        The issue id
        """
        return pulumi.get(self, "issue_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The issue description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> Optional[str]:
        """
        The issue type. Value must be one of `issue`, `incident`, `test_case`, `task`.
        """
        return pulumi.get(self, "issue_type")

    @property
    @pulumi.getter
    def labels(self) -> Optional[str]:
        """
        The issue labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The issue title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateGoogleCalendarEventTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventId":
            suggest = "event_id"
        elif key == "adjustmentDays":
            suggest = "adjustment_days"
        elif key == "canGuestsInviteOthers":
            suggest = "can_guests_invite_others"
        elif key == "canGuestsModifyEvent":
            suggest = "can_guests_modify_event"
        elif key == "canGuestsSeeOtherGuests":
            suggest = "can_guests_see_other_guests"
        elif key == "conferenceSolutionKey":
            suggest = "conference_solution_key"
        elif key == "meetingDuration":
            suggest = "meeting_duration"
        elif key == "postToIncidentTimeline":
            suggest = "post_to_incident_timeline"
        elif key == "postToSlackChannels":
            suggest = "post_to_slack_channels"
        elif key == "replaceAttendees":
            suggest = "replace_attendees"
        elif key == "sendUpdates":
            suggest = "send_updates"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "timeOfMeeting":
            suggest = "time_of_meeting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateGoogleCalendarEventTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateGoogleCalendarEventTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateGoogleCalendarEventTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_id: str,
                 adjustment_days: Optional[int] = None,
                 attendees: Optional[Sequence[str]] = None,
                 can_guests_invite_others: Optional[bool] = None,
                 can_guests_modify_event: Optional[bool] = None,
                 can_guests_see_other_guests: Optional[bool] = None,
                 conference_solution_key: Optional[str] = None,
                 description: Optional[str] = None,
                 meeting_duration: Optional[str] = None,
                 post_to_incident_timeline: Optional[bool] = None,
                 post_to_slack_channels: Optional[Sequence['outputs.WorkflowTaskUpdateGoogleCalendarEventTaskParamsPostToSlackChannel']] = None,
                 replace_attendees: Optional[bool] = None,
                 send_updates: Optional[bool] = None,
                 summary: Optional[str] = None,
                 task_type: Optional[str] = None,
                 time_of_meeting: Optional[str] = None):
        """
        :param str event_id: The event ID
        :param int adjustment_days: Days to adjust meeting by
        :param Sequence[str] attendees: Emails of attendees
        :param bool can_guests_invite_others: Value must be one of true or false
        :param bool can_guests_modify_event: Value must be one of true or false
        :param bool can_guests_see_other_guests: Value must be one of true or false
        :param str conference_solution_key: Sets the video conference type attached to the meeting. Value must be one of `eventHangout`, `eventNamedHangout`, `hangoutsMeet`, `addOn`.
        :param str description: The event description
        :param str meeting_duration: Meeting duration in format like '1 hour', '30 minutes'
        :param bool post_to_incident_timeline: Value must be one of true or false
        :param bool replace_attendees: Value must be one of true or false
        :param bool send_updates: Send an email to the attendees notifying them of the event. Value must be one of true or false
        :param str summary: The event summary
        :param str time_of_meeting: Time of meeting in format HH:MM
        """
        pulumi.set(__self__, "event_id", event_id)
        if adjustment_days is not None:
            pulumi.set(__self__, "adjustment_days", adjustment_days)
        if attendees is not None:
            pulumi.set(__self__, "attendees", attendees)
        if can_guests_invite_others is not None:
            pulumi.set(__self__, "can_guests_invite_others", can_guests_invite_others)
        if can_guests_modify_event is not None:
            pulumi.set(__self__, "can_guests_modify_event", can_guests_modify_event)
        if can_guests_see_other_guests is not None:
            pulumi.set(__self__, "can_guests_see_other_guests", can_guests_see_other_guests)
        if conference_solution_key is not None:
            pulumi.set(__self__, "conference_solution_key", conference_solution_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if meeting_duration is not None:
            pulumi.set(__self__, "meeting_duration", meeting_duration)
        if post_to_incident_timeline is not None:
            pulumi.set(__self__, "post_to_incident_timeline", post_to_incident_timeline)
        if post_to_slack_channels is not None:
            pulumi.set(__self__, "post_to_slack_channels", post_to_slack_channels)
        if replace_attendees is not None:
            pulumi.set(__self__, "replace_attendees", replace_attendees)
        if send_updates is not None:
            pulumi.set(__self__, "send_updates", send_updates)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if time_of_meeting is not None:
            pulumi.set(__self__, "time_of_meeting", time_of_meeting)

    @property
    @pulumi.getter(name="eventId")
    def event_id(self) -> str:
        """
        The event ID
        """
        return pulumi.get(self, "event_id")

    @property
    @pulumi.getter(name="adjustmentDays")
    def adjustment_days(self) -> Optional[int]:
        """
        Days to adjust meeting by
        """
        return pulumi.get(self, "adjustment_days")

    @property
    @pulumi.getter
    def attendees(self) -> Optional[Sequence[str]]:
        """
        Emails of attendees
        """
        return pulumi.get(self, "attendees")

    @property
    @pulumi.getter(name="canGuestsInviteOthers")
    def can_guests_invite_others(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "can_guests_invite_others")

    @property
    @pulumi.getter(name="canGuestsModifyEvent")
    def can_guests_modify_event(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "can_guests_modify_event")

    @property
    @pulumi.getter(name="canGuestsSeeOtherGuests")
    def can_guests_see_other_guests(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "can_guests_see_other_guests")

    @property
    @pulumi.getter(name="conferenceSolutionKey")
    def conference_solution_key(self) -> Optional[str]:
        """
        Sets the video conference type attached to the meeting. Value must be one of `eventHangout`, `eventNamedHangout`, `hangoutsMeet`, `addOn`.
        """
        return pulumi.get(self, "conference_solution_key")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The event description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="meetingDuration")
    def meeting_duration(self) -> Optional[str]:
        """
        Meeting duration in format like '1 hour', '30 minutes'
        """
        return pulumi.get(self, "meeting_duration")

    @property
    @pulumi.getter(name="postToIncidentTimeline")
    def post_to_incident_timeline(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "post_to_incident_timeline")

    @property
    @pulumi.getter(name="postToSlackChannels")
    def post_to_slack_channels(self) -> Optional[Sequence['outputs.WorkflowTaskUpdateGoogleCalendarEventTaskParamsPostToSlackChannel']]:
        return pulumi.get(self, "post_to_slack_channels")

    @property
    @pulumi.getter(name="replaceAttendees")
    def replace_attendees(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "replace_attendees")

    @property
    @pulumi.getter(name="sendUpdates")
    def send_updates(self) -> Optional[bool]:
        """
        Send an email to the attendees notifying them of the event. Value must be one of true or false
        """
        return pulumi.get(self, "send_updates")

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        The event summary
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="timeOfMeeting")
    def time_of_meeting(self) -> Optional[str]:
        """
        Time of meeting in format HH:MM
        """
        return pulumi.get(self, "time_of_meeting")


@pulumi.output_type
class WorkflowTaskUpdateGoogleCalendarEventTaskParamsPostToSlackChannel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskUpdateGoogleDocsPageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileId":
            suggest = "file_id"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "templateId":
            suggest = "template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateGoogleDocsPageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateGoogleDocsPageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateGoogleDocsPageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_id: str,
                 content: Optional[str] = None,
                 post_mortem_template_id: Optional[str] = None,
                 task_type: Optional[str] = None,
                 template_id: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str file_id: The Google Doc file ID
        :param str content: The Google Doc content
        :param str post_mortem_template_id: Retrospective template to use when updating page, if desired
        :param str template_id: The Google Doc file ID to use as a template.
        :param str title: The Google Doc title
        """
        pulumi.set(__self__, "file_id", file_id)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> str:
        """
        The Google Doc file ID
        """
        return pulumi.get(self, "file_id")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The Google Doc content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        Retrospective template to use when updating page, if desired
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[str]:
        """
        The Google Doc file ID to use as a template.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The Google Doc title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateIncidentPostmortemTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postmortemId":
            suggest = "postmortem_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateIncidentPostmortemTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateIncidentPostmortemTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateIncidentPostmortemTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 postmortem_id: str,
                 status: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str postmortem_id: UUID of the retrospective that needs to be updated
        :param str title: The incident title
        """
        pulumi.set(__self__, "postmortem_id", postmortem_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="postmortemId")
    def postmortem_id(self) -> str:
        """
        UUID of the retrospective that needs to be updated
        """
        return pulumi.get(self, "postmortem_id")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The incident title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateIncidentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentId":
            suggest = "incident_id"
        elif key == "acknowledgedAt":
            suggest = "acknowledged_at"
        elif key == "attributeToQueryBy":
            suggest = "attribute_to_query_by"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "detectedAt":
            suggest = "detected_at"
        elif key == "environmentIds":
            suggest = "environment_ids"
        elif key == "functionalityIds":
            suggest = "functionality_ids"
        elif key == "groupIds":
            suggest = "group_ids"
        elif key == "incidentTypeIds":
            suggest = "incident_type_ids"
        elif key == "mitigatedAt":
            suggest = "mitigated_at"
        elif key == "resolvedAt":
            suggest = "resolved_at"
        elif key == "serviceIds":
            suggest = "service_ids"
        elif key == "severityId":
            suggest = "severity_id"
        elif key == "startedAt":
            suggest = "started_at"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateIncidentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateIncidentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateIncidentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_id: str,
                 acknowledged_at: Optional[str] = None,
                 attribute_to_query_by: Optional[str] = None,
                 custom_fields_mapping: Optional[str] = None,
                 detected_at: Optional[str] = None,
                 environment_ids: Optional[Sequence[str]] = None,
                 functionality_ids: Optional[Sequence[str]] = None,
                 group_ids: Optional[Sequence[str]] = None,
                 incident_type_ids: Optional[Sequence[str]] = None,
                 mitigated_at: Optional[str] = None,
                 private: Optional[bool] = None,
                 resolved_at: Optional[str] = None,
                 service_ids: Optional[Sequence[str]] = None,
                 severity_id: Optional[str] = None,
                 started_at: Optional[str] = None,
                 status: Optional[str] = None,
                 summary: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str incident_id: The incident id to update or id of any attribute on the incident
        :param str attribute_to_query_by: Value must be one of `id`, `slug`, `sequential_id`, `pagerduty_incident_id`, `opsgenie_incident_id`, `victor_ops_incident_id`, `jira_issue_id`, `asana_task_id`, `shortcut_task_id`, `linear_issue_id`, `zendesk_ticket_id`, `trello_card_id`, `airtable_record_id`, `shortcut_story_id`, `github_issue_id`, `gitlab_issue_id`, `freshservice_ticket_id`, `freshservice_task_id`, `clickup_task_id`.
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param bool private: Value must be one of true or false
        :param str summary: The incident summary
        :param str title: The incident title
        """
        pulumi.set(__self__, "incident_id", incident_id)
        if acknowledged_at is not None:
            pulumi.set(__self__, "acknowledged_at", acknowledged_at)
        if attribute_to_query_by is not None:
            pulumi.set(__self__, "attribute_to_query_by", attribute_to_query_by)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if detected_at is not None:
            pulumi.set(__self__, "detected_at", detected_at)
        if environment_ids is not None:
            pulumi.set(__self__, "environment_ids", environment_ids)
        if functionality_ids is not None:
            pulumi.set(__self__, "functionality_ids", functionality_ids)
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if incident_type_ids is not None:
            pulumi.set(__self__, "incident_type_ids", incident_type_ids)
        if mitigated_at is not None:
            pulumi.set(__self__, "mitigated_at", mitigated_at)
        if private is not None:
            pulumi.set(__self__, "private", private)
        if resolved_at is not None:
            pulumi.set(__self__, "resolved_at", resolved_at)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)
        if severity_id is not None:
            pulumi.set(__self__, "severity_id", severity_id)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="incidentId")
    def incident_id(self) -> str:
        """
        The incident id to update or id of any attribute on the incident
        """
        return pulumi.get(self, "incident_id")

    @property
    @pulumi.getter(name="acknowledgedAt")
    def acknowledged_at(self) -> Optional[str]:
        return pulumi.get(self, "acknowledged_at")

    @property
    @pulumi.getter(name="attributeToQueryBy")
    def attribute_to_query_by(self) -> Optional[str]:
        """
        Value must be one of `id`, `slug`, `sequential_id`, `pagerduty_incident_id`, `opsgenie_incident_id`, `victor_ops_incident_id`, `jira_issue_id`, `asana_task_id`, `shortcut_task_id`, `linear_issue_id`, `zendesk_ticket_id`, `trello_card_id`, `airtable_record_id`, `shortcut_story_id`, `github_issue_id`, `gitlab_issue_id`, `freshservice_ticket_id`, `freshservice_task_id`, `clickup_task_id`.
        """
        return pulumi.get(self, "attribute_to_query_by")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter(name="detectedAt")
    def detected_at(self) -> Optional[str]:
        return pulumi.get(self, "detected_at")

    @property
    @pulumi.getter(name="environmentIds")
    def environment_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "environment_ids")

    @property
    @pulumi.getter(name="functionalityIds")
    def functionality_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "functionality_ids")

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="incidentTypeIds")
    def incident_type_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "incident_type_ids")

    @property
    @pulumi.getter(name="mitigatedAt")
    def mitigated_at(self) -> Optional[str]:
        return pulumi.get(self, "mitigated_at")

    @property
    @pulumi.getter
    def private(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="resolvedAt")
    def resolved_at(self) -> Optional[str]:
        return pulumi.get(self, "resolved_at")

    @property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_ids")

    @property
    @pulumi.getter(name="severityId")
    def severity_id(self) -> Optional[str]:
        return pulumi.get(self, "severity_id")

    @property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[str]:
        return pulumi.get(self, "started_at")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        The incident summary
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The incident title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateJiraIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issueId":
            suggest = "issue_id"
        elif key == "projectKey":
            suggest = "project_key"
        elif key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "reporterUserEmail":
            suggest = "reporter_user_email"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "updatePayload":
            suggest = "update_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateJiraIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateJiraIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateJiraIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issue_id: str,
                 project_key: str,
                 assign_user_email: Optional[str] = None,
                 custom_fields_mapping: Optional[str] = None,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 labels: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 reporter_user_email: Optional[str] = None,
                 status: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None,
                 update_payload: Optional[str] = None):
        """
        :param str issue_id: The issue id
        :param str project_key: The project key
        :param str assign_user_email: The assigned user's email
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str description: The issue description
        :param str due_date: The due date
        :param str labels: The issue labels
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param str reporter_user_email: The reporter user's email
        :param Mapping[str, str] status: Map must contain two fields, `id` and `name`. The status id and display name
        :param str title: The issue title
        :param str update_payload: Update payload. Can contain liquid markup and need to be valid JSON
        """
        pulumi.set(__self__, "issue_id", issue_id)
        pulumi.set(__self__, "project_key", project_key)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if reporter_user_email is not None:
            pulumi.set(__self__, "reporter_user_email", reporter_user_email)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if update_payload is not None:
            pulumi.set(__self__, "update_payload", update_payload)

    @property
    @pulumi.getter(name="issueId")
    def issue_id(self) -> str:
        """
        The issue id
        """
        return pulumi.get(self, "issue_id")

    @property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> str:
        """
        The project key
        """
        return pulumi.get(self, "project_key")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The issue description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def labels(self) -> Optional[str]:
        """
        The issue labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="reporterUserEmail")
    def reporter_user_email(self) -> Optional[str]:
        """
        The reporter user's email
        """
        return pulumi.get(self, "reporter_user_email")

    @property
    @pulumi.getter
    def status(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The status id and display name
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="updatePayload")
    def update_payload(self) -> Optional[str]:
        """
        Update payload. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "update_payload")


@pulumi.output_type
class WorkflowTaskUpdateLinearIssueTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issueId":
            suggest = "issue_id"
        elif key == "assignUserEmail":
            suggest = "assign_user_email"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateLinearIssueTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateLinearIssueTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateLinearIssueTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issue_id: str,
                 assign_user_email: Optional[str] = None,
                 description: Optional[str] = None,
                 labels: Optional[Sequence['outputs.WorkflowTaskUpdateLinearIssueTaskParamsLabel']] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 project: Optional[Mapping[str, str]] = None,
                 state: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str issue_id: The issue id
        :param str assign_user_email: The assigned user's email
        :param str description: The issue description
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param Mapping[str, str] project: Map must contain two fields, `id` and `name`. The project id and display name
        :param Mapping[str, str] state: Map must contain two fields, `id` and `name`. The state id and display name
        :param str title: The issue title
        """
        pulumi.set(__self__, "issue_id", issue_id)
        if assign_user_email is not None:
            pulumi.set(__self__, "assign_user_email", assign_user_email)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="issueId")
    def issue_id(self) -> str:
        """
        The issue id
        """
        return pulumi.get(self, "issue_id")

    @property
    @pulumi.getter(name="assignUserEmail")
    def assign_user_email(self) -> Optional[str]:
        """
        The assigned user's email
        """
        return pulumi.get(self, "assign_user_email")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The issue description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.WorkflowTaskUpdateLinearIssueTaskParamsLabel']]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def project(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The project id and display name
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def state(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The state id and display name
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The issue title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateLinearIssueTaskParamsLabel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskUpdateNotionPageTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileId":
            suggest = "file_id"
        elif key == "postMortemTemplateId":
            suggest = "post_mortem_template_id"
        elif key == "showActionItemsAsTable":
            suggest = "show_action_items_as_table"
        elif key == "showTimelineAsTable":
            suggest = "show_timeline_as_table"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateNotionPageTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateNotionPageTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateNotionPageTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_id: str,
                 post_mortem_template_id: Optional[str] = None,
                 show_action_items_as_table: Optional[bool] = None,
                 show_timeline_as_table: Optional[bool] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str file_id: The Notion page ID
        :param str post_mortem_template_id: Retrospective template to use when creating page task, if desired
        :param bool show_action_items_as_table: Value must be one of true or false
        :param bool show_timeline_as_table: Value must be one of true or false
        :param str title: The Notion page title
        """
        pulumi.set(__self__, "file_id", file_id)
        if post_mortem_template_id is not None:
            pulumi.set(__self__, "post_mortem_template_id", post_mortem_template_id)
        if show_action_items_as_table is not None:
            pulumi.set(__self__, "show_action_items_as_table", show_action_items_as_table)
        if show_timeline_as_table is not None:
            pulumi.set(__self__, "show_timeline_as_table", show_timeline_as_table)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> str:
        """
        The Notion page ID
        """
        return pulumi.get(self, "file_id")

    @property
    @pulumi.getter(name="postMortemTemplateId")
    def post_mortem_template_id(self) -> Optional[str]:
        """
        Retrospective template to use when creating page task, if desired
        """
        return pulumi.get(self, "post_mortem_template_id")

    @property
    @pulumi.getter(name="showActionItemsAsTable")
    def show_action_items_as_table(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "show_action_items_as_table")

    @property
    @pulumi.getter(name="showTimelineAsTable")
    def show_timeline_as_table(self) -> Optional[bool]:
        """
        Value must be one of true or false
        """
        return pulumi.get(self, "show_timeline_as_table")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The Notion page title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateOpsgenieAlertTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateOpsgenieAlertTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateOpsgenieAlertTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateOpsgenieAlertTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 completion: Mapping[str, str],
                 priority: str,
                 description: Optional[str] = None,
                 message: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str alert_id: Opsgenie Alert ID
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`.
        :param str priority: Value must be one of `P1`, `P2`, `P3`, `P4`, `P5`, `auto`.
        :param str description: Description field of the alert that is generally used to provide a detailed information about the alert
        :param str message: Message of the alert
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "completion", completion)
        pulumi.set(__self__, "priority", priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        Opsgenie Alert ID
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def completion(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter
    def priority(self) -> str:
        """
        Value must be one of `P1`, `P2`, `P3`, `P4`, `P5`, `auto`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description field of the alert that is generally used to provide a detailed information about the alert
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message of the alert
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateOpsgenieIncidentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opsgenieIncidentId":
            suggest = "opsgenie_incident_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateOpsgenieIncidentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateOpsgenieIncidentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateOpsgenieIncidentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opsgenie_incident_id: str,
                 description: Optional[str] = None,
                 message: Optional[str] = None,
                 priority: Optional[str] = None,
                 status: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str opsgenie_incident_id: The Opsgenie incident ID, this can also be a Rootly incident variable
        :param str description: Description field of the alert that is generally used to provide a detailed information about the alert
        :param str message: Message of the alert
        :param str priority: Value must be one of `P1`, `P2`, `P3`, `P4`, `P5`, `auto`.
        :param str status: Value must be one of `resolve`, `open`, `close`, `auto`.
        """
        pulumi.set(__self__, "opsgenie_incident_id", opsgenie_incident_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="opsgenieIncidentId")
    def opsgenie_incident_id(self) -> str:
        """
        The Opsgenie incident ID, this can also be a Rootly incident variable
        """
        return pulumi.get(self, "opsgenie_incident_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description field of the alert that is generally used to provide a detailed information about the alert
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message of the alert
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        Value must be one of `P1`, `P2`, `P3`, `P4`, `P5`, `auto`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Value must be one of `resolve`, `open`, `close`, `auto`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdatePagerdutyIncidentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagerdutyIncidentId":
            suggest = "pagerduty_incident_id"
        elif key == "escalationLevel":
            suggest = "escalation_level"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdatePagerdutyIncidentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdatePagerdutyIncidentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdatePagerdutyIncidentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pagerduty_incident_id: str,
                 escalation_level: Optional[int] = None,
                 priority: Optional[str] = None,
                 resolution: Optional[str] = None,
                 status: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None,
                 urgency: Optional[str] = None):
        """
        :param str pagerduty_incident_id: Pagerduty incident id
        :param int escalation_level: Escalation level of policy attached to incident
        :param str priority: PagerDuty incident priority, selecting auto will let Rootly auto map our incident severity
        :param str resolution: A message outlining the incident's resolution in PagerDuty
        :param str status: Value must be one of `resolved`, `acknowledged`, `auto`.
        :param str title: Title to update to
        :param str urgency: PagerDuty incident urgency, selecting auto will let Rootly auto map our incident severity. Value must be one of `high`, `low`, `auto`.
        """
        pulumi.set(__self__, "pagerduty_incident_id", pagerduty_incident_id)
        if escalation_level is not None:
            pulumi.set(__self__, "escalation_level", escalation_level)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter(name="pagerdutyIncidentId")
    def pagerduty_incident_id(self) -> str:
        """
        Pagerduty incident id
        """
        return pulumi.get(self, "pagerduty_incident_id")

    @property
    @pulumi.getter(name="escalationLevel")
    def escalation_level(self) -> Optional[int]:
        """
        Escalation level of policy attached to incident
        """
        return pulumi.get(self, "escalation_level")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        PagerDuty incident priority, selecting auto will let Rootly auto map our incident severity
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        """
        A message outlining the incident's resolution in PagerDuty
        """
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Value must be one of `resolved`, `acknowledged`, `auto`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title to update to
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        PagerDuty incident urgency, selecting auto will let Rootly auto map our incident severity. Value must be one of `high`, `low`, `auto`.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class WorkflowTaskUpdatePagertreeAlertTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagertreeAlertId":
            suggest = "pagertree_alert_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdatePagertreeAlertTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdatePagertreeAlertTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdatePagertreeAlertTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 incident: Optional[bool] = None,
                 pagertree_alert_id: Optional[str] = None,
                 severity: Optional[str] = None,
                 task_type: Optional[str] = None,
                 teams: Optional[Sequence['outputs.WorkflowTaskUpdatePagertreeAlertTaskParamsTeam']] = None,
                 title: Optional[str] = None,
                 urgency: Optional[str] = None,
                 users: Optional[Sequence['outputs.WorkflowTaskUpdatePagertreeAlertTaskParamsUser']] = None):
        """
        :param str description: Description of alert as text
        :param bool incident: Setting to true makes an alert a Pagertree incident. Value must be one of true or false
        :param str pagertree_alert_id: The prefix ID of the Pagertree alert
        :param str severity: Value must be one of `auto`, `SEV-1`, `SEV-2`, `SEV-3`, `SEV-4`.
        :param str title: Title of alert as text
        :param str urgency: Value must be one of `auto`, `critical`, `high`, `medium`, `low`.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if incident is not None:
            pulumi.set(__self__, "incident", incident)
        if pagertree_alert_id is not None:
            pulumi.set(__self__, "pagertree_alert_id", pagertree_alert_id)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of alert as text
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def incident(self) -> Optional[bool]:
        """
        Setting to true makes an alert a Pagertree incident. Value must be one of true or false
        """
        return pulumi.get(self, "incident")

    @property
    @pulumi.getter(name="pagertreeAlertId")
    def pagertree_alert_id(self) -> Optional[str]:
        """
        The prefix ID of the Pagertree alert
        """
        return pulumi.get(self, "pagertree_alert_id")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Value must be one of `auto`, `SEV-1`, `SEV-2`, `SEV-3`, `SEV-4`.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence['outputs.WorkflowTaskUpdatePagertreeAlertTaskParamsTeam']]:
        return pulumi.get(self, "teams")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of alert as text
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        Value must be one of `auto`, `critical`, `high`, `medium`, `low`.
        """
        return pulumi.get(self, "urgency")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.WorkflowTaskUpdatePagertreeAlertTaskParamsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class WorkflowTaskUpdatePagertreeAlertTaskParamsTeam(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskUpdatePagertreeAlertTaskParamsUser(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskUpdateServiceNowIncidentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentId":
            suggest = "incident_id"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateServiceNowIncidentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateServiceNowIncidentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateServiceNowIncidentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_id: str,
                 completion: Optional[Mapping[str, str]] = None,
                 custom_fields_mapping: Optional[str] = None,
                 description: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str incident_id: The incident id
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`. The completion id and display name
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param str description: The incident description
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param str title: The incident title
        """
        pulumi.set(__self__, "incident_id", incident_id)
        if completion is not None:
            pulumi.set(__self__, "completion", completion)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="incidentId")
    def incident_id(self) -> str:
        """
        The incident id
        """
        return pulumi.get(self, "incident_id")

    @property
    @pulumi.getter
    def completion(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The completion id and display name
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The incident description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The incident title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateShortcutStoryTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storyId":
            suggest = "story_id"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateShortcutStoryTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateShortcutStoryTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateShortcutStoryTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archivation: Mapping[str, str],
                 story_id: str,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 labels: Optional[str] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param Mapping[str, str] archivation: Map must contain two fields, `id` and `name`. The archivation id and display name
        :param str story_id: The story id
        :param str description: The incident description
        :param str due_date: The due date
        :param str labels: The story labels
        :param str title: The incident title
        """
        pulumi.set(__self__, "archivation", archivation)
        pulumi.set(__self__, "story_id", story_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def archivation(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The archivation id and display name
        """
        return pulumi.get(self, "archivation")

    @property
    @pulumi.getter(name="storyId")
    def story_id(self) -> str:
        """
        The story id
        """
        return pulumi.get(self, "story_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The incident description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def labels(self) -> Optional[str]:
        """
        The story labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The incident title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateShortcutTaskTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentStoryId":
            suggest = "parent_story_id"
        elif key == "taskId":
            suggest = "task_id"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateShortcutTaskTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateShortcutTaskTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateShortcutTaskTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completion: Mapping[str, str],
                 parent_story_id: str,
                 task_id: str,
                 description: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`. The completion id and display name
        :param str parent_story_id: The parent story
        :param str task_id: The task id
        :param str description: The task description
        """
        pulumi.set(__self__, "completion", completion)
        pulumi.set(__self__, "parent_story_id", parent_story_id)
        pulumi.set(__self__, "task_id", task_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def completion(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The completion id and display name
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="parentStoryId")
    def parent_story_id(self) -> str:
        """
        The parent story
        """
        return pulumi.get(self, "parent_story_id")

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> str:
        """
        The task id
        """
        return pulumi.get(self, "task_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The task description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateSlackChannelTopicTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateSlackChannelTopicTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateSlackChannelTopicTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateSlackChannelTopicTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Mapping[str, str],
                 topic: str,
                 task_type: Optional[str] = None):
        """
        :param Mapping[str, str] channel: Map must contain two fields, `id` and `name`.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "topic", topic)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def channel(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter
    def topic(self) -> str:
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateStatusTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateStatusTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateStatusTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateStatusTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 inactivity_timeout: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str status: Value must be one of `in_triage`, `started`, `mitigated`, `resolved`, `cancelled`.
        :param str inactivity_timeout: In format '1 hour', '1 day', etc
        """
        pulumi.set(__self__, "status", status)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Value must be one of `in_triage`, `started`, `mitigated`, `resolved`, `cancelled`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[str]:
        """
        In format '1 hour', '1 day', etc
        """
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateTrelloCardTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cardId":
            suggest = "card_id"
        elif key == "dueDate":
            suggest = "due_date"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateTrelloCardTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateTrelloCardTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateTrelloCardTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archivation: Mapping[str, str],
                 card_id: str,
                 board: Optional[Mapping[str, str]] = None,
                 description: Optional[str] = None,
                 due_date: Optional[str] = None,
                 labels: Optional[Sequence['outputs.WorkflowTaskUpdateTrelloCardTaskParamsLabel']] = None,
                 list: Optional[Mapping[str, str]] = None,
                 task_type: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param Mapping[str, str] archivation: Map must contain two fields, `id` and `name`. The archivation id and display name
        :param str card_id: The card id
        :param Mapping[str, str] board: Map must contain two fields, `id` and `name`. The board id and display name
        :param str description: The card description
        :param str due_date: The due date
        :param Mapping[str, str] list: Map must contain two fields, `id` and `name`. The list id and display name
        :param str title: The card title
        """
        pulumi.set(__self__, "archivation", archivation)
        pulumi.set(__self__, "card_id", card_id)
        if board is not None:
            pulumi.set(__self__, "board", board)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if due_date is not None:
            pulumi.set(__self__, "due_date", due_date)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if list is not None:
            pulumi.set(__self__, "list", list)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def archivation(self) -> Mapping[str, str]:
        """
        Map must contain two fields, `id` and `name`. The archivation id and display name
        """
        return pulumi.get(self, "archivation")

    @property
    @pulumi.getter(name="cardId")
    def card_id(self) -> str:
        """
        The card id
        """
        return pulumi.get(self, "card_id")

    @property
    @pulumi.getter
    def board(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The board id and display name
        """
        return pulumi.get(self, "board")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The card description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> Optional[str]:
        """
        The due date
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.WorkflowTaskUpdateTrelloCardTaskParamsLabel']]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def list(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The list id and display name
        """
        return pulumi.get(self, "list")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The card title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WorkflowTaskUpdateTrelloCardTaskParamsLabel(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkflowTaskUpdateVictorOpsIncidentTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "victorOpsIncidentId":
            suggest = "victor_ops_incident_id"
        elif key == "resolutionMessage":
            suggest = "resolution_message"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateVictorOpsIncidentTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateVictorOpsIncidentTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateVictorOpsIncidentTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 victor_ops_incident_id: str,
                 resolution_message: Optional[str] = None,
                 task_type: Optional[str] = None):
        """
        :param str status: Value must be one of `resolve`, `ack`, `auto`.
        :param str victor_ops_incident_id: The victor_ops incident ID, this can also be a Rootly incident variable
        :param str resolution_message: Resolution message
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "victor_ops_incident_id", victor_ops_incident_id)
        if resolution_message is not None:
            pulumi.set(__self__, "resolution_message", resolution_message)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Value must be one of `resolve`, `ack`, `auto`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="victorOpsIncidentId")
    def victor_ops_incident_id(self) -> str:
        """
        The victor_ops incident ID, this can also be a Rootly incident variable
        """
        return pulumi.get(self, "victor_ops_incident_id")

    @property
    @pulumi.getter(name="resolutionMessage")
    def resolution_message(self) -> Optional[str]:
        """
        Resolution message
        """
        return pulumi.get(self, "resolution_message")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class WorkflowTaskUpdateZendeskTicketTaskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ticketId":
            suggest = "ticket_id"
        elif key == "customFieldsMapping":
            suggest = "custom_fields_mapping"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "ticketPayload":
            suggest = "ticket_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskUpdateZendeskTicketTaskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskUpdateZendeskTicketTaskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskUpdateZendeskTicketTaskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ticket_id: str,
                 completion: Optional[Mapping[str, str]] = None,
                 custom_fields_mapping: Optional[str] = None,
                 priority: Optional[Mapping[str, str]] = None,
                 subject: Optional[str] = None,
                 tags: Optional[str] = None,
                 task_type: Optional[str] = None,
                 ticket_payload: Optional[str] = None):
        """
        :param str ticket_id: The ticket id
        :param Mapping[str, str] completion: Map must contain two fields, `id` and `name`. The completion id and display name
        :param str custom_fields_mapping: Custom field mappings. Can contain liquid markup and need to be valid JSON
        :param Mapping[str, str] priority: Map must contain two fields, `id` and `name`. The priority id and display name
        :param str subject: The ticket subject
        :param str tags: The ticket tags
        :param str ticket_payload: Additional Zendesk ticket attributes. Will be merged into whatever was specified in this tasks current parameters. Can contain liquid markup and need to be valid JSON
        """
        pulumi.set(__self__, "ticket_id", ticket_id)
        if completion is not None:
            pulumi.set(__self__, "completion", completion)
        if custom_fields_mapping is not None:
            pulumi.set(__self__, "custom_fields_mapping", custom_fields_mapping)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)
        if ticket_payload is not None:
            pulumi.set(__self__, "ticket_payload", ticket_payload)

    @property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> str:
        """
        The ticket id
        """
        return pulumi.get(self, "ticket_id")

    @property
    @pulumi.getter
    def completion(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The completion id and display name
        """
        return pulumi.get(self, "completion")

    @property
    @pulumi.getter(name="customFieldsMapping")
    def custom_fields_mapping(self) -> Optional[str]:
        """
        Custom field mappings. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "custom_fields_mapping")

    @property
    @pulumi.getter
    def priority(self) -> Optional[Mapping[str, str]]:
        """
        Map must contain two fields, `id` and `name`. The priority id and display name
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        """
        The ticket subject
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def tags(self) -> Optional[str]:
        """
        The ticket tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[str]:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="ticketPayload")
    def ticket_payload(self) -> Optional[str]:
        """
        Additional Zendesk ticket attributes. Will be merged into whatever was specified in this tasks current parameters. Can contain liquid markup and need to be valid JSON
        """
        return pulumi.get(self, "ticket_payload")


@pulumi.output_type
class GetCausesCauseResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 name: str,
                 slug: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetCustomFieldOptionsCustomFieldOptionResult(dict):
    def __init__(__self__, *,
                 color: str,
                 custom_field_id: int,
                 id: str,
                 position: int,
                 value: str):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "custom_field_id", custom_field_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="customFieldId")
    def custom_field_id(self) -> int:
        return pulumi.get(self, "custom_field_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def position(self) -> int:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCustomFieldsCustomFieldResult(dict):
    def __init__(__self__, *,
                 description: str,
                 enabled: bool,
                 id: str,
                 kind: str,
                 label: str,
                 requireds: Sequence[str],
                 showns: Sequence[str],
                 slug: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "requireds", requireds)
        pulumi.set(__self__, "showns", showns)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def requireds(self) -> Sequence[str]:
        return pulumi.get(self, "requireds")

    @property
    @pulumi.getter
    def showns(self) -> Sequence[str]:
        return pulumi.get(self, "showns")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetEnvironmentsEnvironmentResult(dict):
    def __init__(__self__, *,
                 color: str,
                 description: str,
                 id: str,
                 name: str,
                 slug: str):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetFunctionalitiesFunctionalityResult(dict):
    def __init__(__self__, *,
                 color: str,
                 description: str,
                 id: str,
                 name: str,
                 slug: str):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetIncidentRolesIncidentRoleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 enabled: bool,
                 id: str,
                 name: str,
                 slug: str,
                 summary: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)
        pulumi.set(__self__, "summary", summary)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")

    @property
    @pulumi.getter
    def summary(self) -> str:
        return pulumi.get(self, "summary")


@pulumi.output_type
class GetIncidentTypesIncidentTypeResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 name: str,
                 slug: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetServicesServiceResult(dict):
    def __init__(__self__, *,
                 color: str,
                 description: str,
                 id: str,
                 name: str,
                 public_description: str,
                 slug: str):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_description", public_description)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicDescription")
    def public_description(self) -> str:
        return pulumi.get(self, "public_description")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetSeveritiesSeverityResult(dict):
    def __init__(__self__, *,
                 color: str,
                 description: str,
                 id: str,
                 name: str,
                 severity: str,
                 slug: str):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def severity(self) -> str:
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetTeamsTeamResult(dict):
    def __init__(__self__, *,
                 color: str,
                 description: str,
                 id: str,
                 name: str,
                 slug: str):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> str:
        return pulumi.get(self, "slug")


